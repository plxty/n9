From 0b232e8b8ca95b2a4f0da612bc3263f181733f0f Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Fri, 5 Dec 2025 17:33:00 +0800
Subject: [PATCH] librime: temp_ascii

---
 src/rime/gear/ascii_composer.cc | 145 ++++++++++++++++++++++++++++++--
 src/rime/gear/punctuator.cc     |   3 +
 2 files changed, 139 insertions(+), 9 deletions(-)

diff --git a/src/rime/gear/ascii_composer.cc b/src/rime/gear/ascii_composer.cc
index a9e333b9..58586a0e 100644
--- a/src/rime/gear/ascii_composer.cc
+++ b/src/rime/gear/ascii_composer.cc
@@ -55,11 +55,140 @@ AsciiComposer::~AsciiComposer() {
   connection_.disconnect();
 }
 
+/**
+ * Temporary ASCII Mode:
+ *
+ * 这个模式只是用来快速编辑英文而不需要频繁 shift 切换输入法的一种尝试。
+ * 它的设计目的在于保证以中文为主、英文为辅下输入的连贯性。因此，它并不适用于
+ * 需要输入大量英文的情况，那种情况下最好的方式就是使用 shift key。
+ *
+ * 在输入中文后可以直接通过按下空格键进入到临时 ASCII 模式，也可以通过大写字母的
+ * 方式进入。直到输入特殊字符（频率最高的应该就是空格了）后解除临时 ASCII 模式。
+ */
+
+static ProcessResult TempAsciiOff(Context* ctx, bool swtch) {
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  if (!ctx->get_option("temp_ascii"))
+    return kNoop;
+  ctx->set_option("temp_ascii", false);
+  // To send one more ascii_mode notification, make the frontend aware.
+  ctx->set_option("ascii_mode", ctx->get_option("ascii_mode"));
+  ctx->commit_history().clear();
+  return kNoop;
+}
+
+// Will clear the commit_history to (try to) avoid inconsistence.
+// Maybe it's unneccessary.
+static ProcessResult TempAsciiOn(Context* ctx, bool swtch) {
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  if (ctx->get_option("temp_ascii"))
+    return kRejected;
+  ctx->set_option("temp_ascii", true);
+  ctx->commit_history().clear();
+  return kRejected;
+}
+
+// Transform means ascii to half or full width symbol in cn, like . to 。.
+// We treat 'a' to 'z' as a transformable character, because in cn, they're
+// "transformed" into real chinese words, huh.
+static bool CanTransform(int ch, bool optional) {
+  if (optional) {
+    switch (ch) {
+      case XK_a ... XK_z:  // regular keys
+      case '.':            // namespace.method, 1.2.3.
+      case '\'':           // it's
+      case '"':            // "string"
+      case '<':            // 1<3
+      case '>':            // pointer->member
+      case ':':            // namespace::nested
+      case '(':            // invoke()
+      case ')':            // revoke()
+      case '[':            // a[4]
+      case ']':            // b[2]
+      case '{':            // {"foh"}
+      case '}':            // {"bah"}
+        return true;
+    }
+  }
+
+  switch (ch) {
+    case ',':
+    case '^':  // true^false?
+    case '\\':
+    case '!':
+    case '?':
+    case ';':
+      return true;
+  }
+
+  return false;
+}
+
+// Here we MUST be !ascii_mode, it isn't in the consideration.
+static ProcessResult TempAsciiProcess(Context* ctx, KeyEvent key, bool swtch) {
+  const int ch = key.keycode();  // actually the `keyval`
+  if (ch == XK_Return) {
+    // return in cn: to temp_ascii if composing
+    if (ctx->IsComposing())
+      TempAsciiOn(ctx, swtch);
+    // return in temp_ascii: to cn
+    else
+      TempAsciiOff(ctx, swtch);
+    return kNoop;
+  }
+
+  // all other keys now handled only !composing (not selecting candidates)
+  if (ctx->IsComposing())
+    return kNoop;
+
+  if (ch == XK_space) {
+    // space (or +shift) in cn: to temp_ascii
+    if (!ctx->get_option("temp_ascii"))
+      return TempAsciiOn(ctx, swtch);
+    // shift+space in temp_ascii: to ascii_mode (behave as shift then space)
+    if (key.shift()) {
+      ctx->set_option("ascii_mode", true);
+      return TempAsciiOff(ctx, true);  // @see ToggleAsciiModeWithKey
+    }
+    // space in temp_ascii: to cn
+    return TempAsciiOff(ctx, swtch);
+  }
+
+  if (ch == XK_BackSpace) {
+    // backspace in cn/temp_ascii: to temp_ascii/cn if just switched temp_ascii
+    if (swtch)
+      return ctx->get_option("temp_ascii") ? TempAsciiOff(ctx, swtch)
+                                           : TempAsciiOn(ctx, swtch);
+    // backspace in any: just do the job
+    return kNoop;
+  }
+
+  if (XK_space <= ch && ch <= XK_asciitilde) {
+    // other in cn: to temp_ascii if !transformable
+    if (!ctx->get_option("temp_ascii"))
+      return CanTransform(ch, true) ? kNoop : TempAsciiOn(ctx, swtch);
+    // other in temp_ascii: to cn if transformable
+    return CanTransform(ch, false) ? TempAsciiOff(ctx, swtch) : kRejected;
+  }
+
+  // what's this unprintable character? we can't do anything really...
+  return kNoop;
+}
+
 ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
-  if ((key_event.shift() && key_event.ctrl()) || key_event.alt() ||
-      key_event.super()) {
+  // TODO: Performance impacts...
+  Context* ctx = engine_->context();
+  const bool swtch_temp_ascii = ctx->get_option("swtch_temp_ascii");
+  // FIXME: For keys like '?' using shift, the swtch will be incorrect...
+  if (swtch_temp_ascii)
+    ctx->set_option("swtch_temp_ascii", false);
+  // not going to use the ctrl key switching ascii_mode (e.g. ctrl+shift).
+  // a.k.a. ctrl in temp_ascii -> cn, may be useful?
+  if (key_event.ctrl() || key_event.alt() || key_event.super()) {
     shift_key_pressed_ = ctrl_key_pressed_ = false;
-    return kNoop;
+    return TempAsciiOff(ctx, swtch_temp_ascii);
   }
   if (caps_lock_switch_style_ != kAsciiModeSwitchNoop) {
     ProcessResult result = ProcessCapsLock(key_event);
@@ -104,11 +233,6 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
   }
   // other keys
   shift_key_pressed_ = ctrl_key_pressed_ = false;
-  // possible key binding: Control+x, Shift+space
-  if (key_event.ctrl() || (key_event.shift() && ch == XK_space)) {
-    return kNoop;
-  }
-  Context* ctx = engine_->context();
   bool ascii_mode = ctx->get_option("ascii_mode");
   if (ascii_mode) {
     if (!ctx->IsComposing()) {
@@ -120,7 +244,9 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
       return kAccepted;
     }
   }
-  return kNoop;
+  if (key_event.release())
+    return kNoop;
+  return TempAsciiProcess(ctx, key_event, swtch_temp_ascii);
 }
 
 ProcessResult AsciiComposer::ProcessCapsLock(const KeyEvent& key_event) {
@@ -207,6 +333,7 @@ bool AsciiComposer::ToggleAsciiModeWithKey(int key_code) {
   Context* ctx = engine_->context();
   bool ascii_mode = !ctx->get_option("ascii_mode");
   SwitchAsciiMode(ascii_mode, style);
+  TempAsciiOff(ctx, true);  // avoid updating the swtch
   toggle_with_caps_ = (key_code == XK_Caps_Lock);
   return true;
 }
diff --git a/src/rime/gear/punctuator.cc b/src/rime/gear/punctuator.cc
index 435babc0..5303bebc 100644
--- a/src/rime/gear/punctuator.cc
+++ b/src/rime/gear/punctuator.cc
@@ -128,6 +128,9 @@ ProcessResult Punctuator::ProcessKeyEvent(const KeyEvent& key_event) {
           AutoCommitPunct(punct_definition) || PairPunct(punct_definition);
     }
   }
+
+  // Drop punctuator in words, to make temp_ascii works:
+  ctx->commit_history().clear();
   return kAccepted;
 }
 
-- 
2.39.5 (Apple Git-154)

