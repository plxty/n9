From 325be0de46c0cbee6015f9271c9d0cceb84eb84c Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Wed, 3 Dec 2025 21:27:52 +0800
Subject: [PATCH] librime: temp_ascii

---
 src/rime/gear/ascii_composer.cc | 133 ++++++++++++++++++++++++++++++--
 src/rime/gear/punctuator.cc     |   3 +
 2 files changed, 129 insertions(+), 7 deletions(-)

diff --git a/src/rime/gear/ascii_composer.cc b/src/rime/gear/ascii_composer.cc
index a9e333b9..2be45cbb 100644
--- a/src/rime/gear/ascii_composer.cc
+++ b/src/rime/gear/ascii_composer.cc
@@ -55,7 +55,126 @@ AsciiComposer::~AsciiComposer() {
   connection_.disconnect();
 }
 
+/**
+ * Temporary ASCII Mode:
+ *
+ * 这个模式只是用来快速编辑英文而不需要频繁 shift 切换输入法的一种尝试。
+ * 它的设计目的在于保证以中文为主、英文为辅下输入的连贯性。因此，它并不适用于
+ * 需要输入大量英文的情况，那种情况下最好的方式就是使用 shift key。
+ *
+ * 在输入中文后可以直接通过按下空格键进入到临时 ASCII 模式，也可以通过大写字母的
+ * 方式进入。直到输入特殊字符（频率最高的应该就是空格了）后解除临时 ASCII 模式。
+ */
+
+static inline ProcessResult TempAsciiOff(Context* ctx, bool swtch) {
+  ctx->set_option("temp_ascii", false);
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  // To send one more ascii_mode notification, make the frontend aware.
+  ctx->set_option("ascii_mode", ctx->get_option("ascii_mode"));
+  ctx->commit_history().clear();
+  return kNoop;
+}
+
+// Will clear the commit_history to (try to) avoid inconsistence.
+// Maybe it's unneccessary.
+static inline ProcessResult TempAsciiOn(Context* ctx, bool swtch) {
+  ctx->set_option("temp_ascii", true);
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  ctx->commit_history().clear();
+  return kRejected;
+}
+
+// May process the half or full width transform?
+static inline bool MayProcessTransform(int ch, bool optional) {
+  // Not printable things, let other handles it:
+  if (!(XK_space <= ch && ch <= XK_asciitilde))
+    return true;
+
+  // Transform while in normal and temp_ascii mode; TODO: XK_ macro?
+  // ... Or to leave the temp_ascii mode.
+  switch (ch) {
+    case ',':
+    case '^':  // true^false
+    case '\\':
+    case '!':
+    case '?':
+    case ';':
+      return true;
+  }
+
+  // Transform while in normal mode, but not in temp_ascii:
+  // ... Or to stay in the temp_ascii mode.
+  if (optional) {
+    switch (ch) {
+      case '.':   // namespace.method, 1.2.3.
+      case '\'':  // it's
+      case '"':   // "string"
+      case '<':   // 1<3
+      case '>':   // pointer->member
+      case ':':   // namespace::nested
+      case '(':   // invoke()
+      case ')':   // revoke()
+      case '[':   // a[4]
+      case ']':   // b[2]
+      case '{':   // {"foh"}
+      case '}':   // {"bah"}
+        return true;
+    }
+  }
+
+  // Other keys may enter the temp_ascii mode, and won't be transformed:
+  return false;
+}
+
+ProcessResult TempAsciiProcess(Context* ctx, KeyEvent key_event, bool swtch) {
+  const int ch = key_event.keycode();  // actually the `keyval`
+  if (key_event.release() || ch == XK_Delete || ctx->IsComposing())
+    return kNoop;
+
+  // Force ascii_mode with shift+space:
+  if (key_event.shift() && ch == XK_space) {
+    ctx->set_option("ascii_mode", true);
+    return TempAsciiOff(ctx, true);  // @see ToggleAsciiModeWithKey
+  }
+
+  if (ctx->get_option("temp_ascii")) {
+    // May entered (swtch) temp_ascii accidently, restore it:
+    if (ch == XK_BackSpace) {
+      if (swtch)
+        return TempAsciiOff(ctx, swtch);
+      return kNoop;
+    }
+
+    if (ch == XK_space || MayProcessTransform(ch, false))
+      return TempAsciiOff(ctx, swtch);
+    return kRejected;
+  }
+
+  // May exit (swtch) temp_ascii accidently, restore it:
+  if (ch == XK_BackSpace) {
+    if (swtch)
+      return TempAsciiOn(ctx, swtch);
+    return kNoop;
+  }
+
+  // Remember here is !temp_ascii, therefore we should consider less keys to
+  // turn this mode on, without damanging the type experience.
+  // That's why we need a `optional`, and it should be `true`.
+  if ((XK_a <= ch && ch <= XK_z) || MayProcessTransform(ch, true))
+    return kNoop;
+  // Some other keys like uppercase, +-*/ and more trigger, including space:
+  return TempAsciiOn(ctx, swtch);
+}
+
 ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
+  // TODO: Performance impacts...
+  Context* ctx = engine_->context();
+  const bool swtch_temp_ascii = ctx->get_option("swtch_temp_ascii");
+  // FIXME: For keys like '?' using shift, the swtch will be incorrect...
+  if (swtch_temp_ascii)
+    ctx->set_option("swtch_temp_ascii", false);
   if ((key_event.shift() && key_event.ctrl()) || key_event.alt() ||
       key_event.super()) {
     shift_key_pressed_ = ctrl_key_pressed_ = false;
@@ -104,11 +223,6 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
   }
   // other keys
   shift_key_pressed_ = ctrl_key_pressed_ = false;
-  // possible key binding: Control+x, Shift+space
-  if (key_event.ctrl() || (key_event.shift() && ch == XK_space)) {
-    return kNoop;
-  }
-  Context* ctx = engine_->context();
   bool ascii_mode = ctx->get_option("ascii_mode");
   if (ascii_mode) {
     if (!ctx->IsComposing()) {
@@ -120,7 +234,7 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
       return kAccepted;
     }
   }
-  return kNoop;
+  return TempAsciiProcess(ctx, key_event, swtch_temp_ascii);
 }
 
 ProcessResult AsciiComposer::ProcessCapsLock(const KeyEvent& key_event) {
@@ -205,8 +319,13 @@ bool AsciiComposer::ToggleAsciiModeWithKey(int key_code) {
     return false;
   AsciiModeSwitchStyle style = it->second;
   Context* ctx = engine_->context();
-  bool ascii_mode = !ctx->get_option("ascii_mode");
+  // When in temp_ascii (previosly cn):
+  // -> shift|space key to switch back to cn
+  // -> shift+space key to switch to ascii_mode
+  bool ascii_mode =
+      !(ctx->get_option("ascii_mode") || ctx->get_option("temp_ascii"));
   SwitchAsciiMode(ascii_mode, style);
+  TempAsciiOff(ctx, true);  // avoid updating the swtch
   toggle_with_caps_ = (key_code == XK_Caps_Lock);
   return true;
 }
diff --git a/src/rime/gear/punctuator.cc b/src/rime/gear/punctuator.cc
index 435babc0..5303bebc 100644
--- a/src/rime/gear/punctuator.cc
+++ b/src/rime/gear/punctuator.cc
@@ -128,6 +128,9 @@ ProcessResult Punctuator::ProcessKeyEvent(const KeyEvent& key_event) {
           AutoCommitPunct(punct_definition) || PairPunct(punct_definition);
     }
   }
+
+  // Drop punctuator in words, to make temp_ascii works:
+  ctx->commit_history().clear();
   return kAccepted;
 }
 
-- 
2.39.5 (Apple Git-154)

