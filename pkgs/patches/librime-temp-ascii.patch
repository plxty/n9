From 2f60315c9b294ca28462b6c2d8678a7a68c1cb27 Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Thu, 4 Dec 2025 17:10:01 +0800
Subject: [PATCH] librime: temp_ascii

---
 src/rime/gear/ascii_composer.cc | 154 ++++++++++++++++++++++++++++++--
 src/rime/gear/punctuator.cc     |   3 +
 2 files changed, 149 insertions(+), 8 deletions(-)

diff --git a/src/rime/gear/ascii_composer.cc b/src/rime/gear/ascii_composer.cc
index a9e333b9..f6e0f3f8 100644
--- a/src/rime/gear/ascii_composer.cc
+++ b/src/rime/gear/ascii_composer.cc
@@ -55,11 +55,149 @@ AsciiComposer::~AsciiComposer() {
   connection_.disconnect();
 }
 
+/**
+ * Temporary ASCII Mode:
+ *
+ * 这个模式只是用来快速编辑英文而不需要频繁 shift 切换输入法的一种尝试。
+ * 它的设计目的在于保证以中文为主、英文为辅下输入的连贯性。因此，它并不适用于
+ * 需要输入大量英文的情况，那种情况下最好的方式就是使用 shift key。
+ *
+ * 在输入中文后可以直接通过按下空格键进入到临时 ASCII 模式，也可以通过大写字母的
+ * 方式进入。直到输入特殊字符（频率最高的应该就是空格了）后解除临时 ASCII 模式。
+ */
+
+static ProcessResult TempAsciiOff(Context* ctx, bool swtch) {
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  if (!ctx->get_option("temp_ascii"))
+    return kNoop;
+  ctx->set_option("temp_ascii", false);
+  // To send one more ascii_mode notification, make the frontend aware.
+  ctx->set_option("ascii_mode", ctx->get_option("ascii_mode"));
+  ctx->commit_history().clear();
+  return kNoop;
+}
+
+// Will clear the commit_history to (try to) avoid inconsistence.
+// Maybe it's unneccessary.
+static ProcessResult TempAsciiOn(Context* ctx, bool swtch) {
+  if (!swtch)
+    ctx->set_option("swtch_temp_ascii", true);
+  if (ctx->get_option("temp_ascii"))
+    return kRejected;
+  ctx->set_option("temp_ascii", true);
+  ctx->commit_history().clear();
+  return kRejected;
+}
+
+// Transform means ascii to half or full width symbol in cn, like . to 。.
+// We treat 'a' to 'z' as a transformable character, because in cn, they're
+// "transformed" into real chinese words, huh.
+static bool CanTransform(int ch, bool optional) {
+  if (optional) {
+    switch (ch) {
+      case XK_a ... XK_z:  // regular keys
+      case '.':            // namespace.method, 1.2.3.
+      case '\'':           // it's
+      case '"':            // "string"
+      case '<':            // 1<3
+      case '>':            // pointer->member
+      case ':':            // namespace::nested
+      case '(':            // invoke()
+      case ')':            // revoke()
+      case '[':            // a[4]
+      case ']':            // b[2]
+      case '{':            // {"foh"}
+      case '}':            // {"bah"}
+        return true;
+    }
+  }
+
+  switch (ch) {
+    case ',':
+    case '^':  // true^false?
+    case '\\':
+    case '!':
+    case '?':
+    case ';':
+      return true;
+  }
+
+  return false;
+}
+
+// Here we MUST be !ascii_mode, it isn't in the consideration.
+static inline ProcessResult TempAsciiProcess(Context* ctx,
+                                             KeyEvent key_event,
+                                             bool swtch) {
+  if (key_event.release())
+    return kNoop;
+
+  const int ch = key_event.keycode();  // actually the `keyval`
+  if (ch == XK_Return) {
+    // return in cn: to temp_ascii if composing
+    if (ctx->IsComposing())
+      TempAsciiOn(ctx, swtch);
+    // return in temp_ascii: to cn
+    else
+      TempAsciiOff(ctx, swtch);
+    return kNoop;  // MUST noop to make the composer commit
+  }
+
+  // all other keys now handled only !composing (not selecting candidates)
+  if (ctx->IsComposing())
+    return kNoop;
+
+  if (ch == XK_space) {
+    // space (or +shift) in cn: to temp_ascii
+    if (!ctx->get_option("temp_ascii"))
+      return TempAsciiOn(ctx, swtch);
+    // shift+space in temp_ascii: to ascii_mode
+    if (key_event.shift()) {
+      ctx->set_option("ascii_mode", true);
+      return TempAsciiOff(ctx, true);  // @see ToggleAsciiModeWithKey
+    }
+    // space in temp_ascii: to cn
+    return TempAsciiOff(ctx, swtch);
+  }
+
+  // no more modifiers are allowed to continue, preventing shortcuts:
+  if (key_event.modifier())
+    return TempAsciiOff(ctx, swtch);
+
+  if (ch == XK_BackSpace) {
+    // backspace in cn/temp_ascii: to temp_ascii/cn if just switched temp_ascii
+    if (swtch)
+      return ctx->get_option("temp_ascii") ? TempAsciiOff(ctx, swtch)
+                                           : TempAsciiOn(ctx, swtch);
+    // backspace in any: just do the job
+    return kNoop;
+  }
+
+  if (XK_space <= ch && ch <= XK_asciitilde) {
+    // other in cn: to temp_ascii if !transformable
+    if (!ctx->get_option("temp_ascii"))
+      return CanTransform(ch, true) ? kNoop : TempAsciiOn(ctx, swtch);
+    // other in temp_ascii: to cn if transformable
+    return CanTransform(ch, false) ? TempAsciiOff(ctx, swtch) : kRejected;
+  }
+
+  // what's this unprintable character? we can't do anything really...
+  return kNoop;
+}
+
 ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
+  // TODO: Performance impacts...
+  Context* ctx = engine_->context();
+  const bool swtch_temp_ascii = ctx->get_option("swtch_temp_ascii");
+  // FIXME: For keys like '?' using shift, the swtch will be incorrect...
+  if (swtch_temp_ascii)
+    ctx->set_option("swtch_temp_ascii", false);
   if ((key_event.shift() && key_event.ctrl()) || key_event.alt() ||
       key_event.super()) {
     shift_key_pressed_ = ctrl_key_pressed_ = false;
-    return kNoop;
+    // triggering shortcuts should reset the temp_ascii, TODO: more?
+    return TempAsciiOff(ctx, swtch_temp_ascii);
   }
   if (caps_lock_switch_style_ != kAsciiModeSwitchNoop) {
     ProcessResult result = ProcessCapsLock(key_event);
@@ -104,11 +242,6 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
   }
   // other keys
   shift_key_pressed_ = ctrl_key_pressed_ = false;
-  // possible key binding: Control+x, Shift+space
-  if (key_event.ctrl() || (key_event.shift() && ch == XK_space)) {
-    return kNoop;
-  }
-  Context* ctx = engine_->context();
   bool ascii_mode = ctx->get_option("ascii_mode");
   if (ascii_mode) {
     if (!ctx->IsComposing()) {
@@ -120,7 +253,7 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
       return kAccepted;
     }
   }
-  return kNoop;
+  return TempAsciiProcess(ctx, key_event, swtch_temp_ascii);
 }
 
 ProcessResult AsciiComposer::ProcessCapsLock(const KeyEvent& key_event) {
@@ -205,8 +338,13 @@ bool AsciiComposer::ToggleAsciiModeWithKey(int key_code) {
     return false;
   AsciiModeSwitchStyle style = it->second;
   Context* ctx = engine_->context();
-  bool ascii_mode = !ctx->get_option("ascii_mode");
+  // When in temp_ascii (previosly cn):
+  // -> shift|space key to switch back to cn
+  // -> shift+space key to switch to ascii_mode
+  bool ascii_mode =
+      !(ctx->get_option("ascii_mode") || ctx->get_option("temp_ascii"));
   SwitchAsciiMode(ascii_mode, style);
+  TempAsciiOff(ctx, true);  // avoid updating the swtch
   toggle_with_caps_ = (key_code == XK_Caps_Lock);
   return true;
 }
diff --git a/src/rime/gear/punctuator.cc b/src/rime/gear/punctuator.cc
index 435babc0..5303bebc 100644
--- a/src/rime/gear/punctuator.cc
+++ b/src/rime/gear/punctuator.cc
@@ -128,6 +128,9 @@ ProcessResult Punctuator::ProcessKeyEvent(const KeyEvent& key_event) {
           AutoCommitPunct(punct_definition) || PairPunct(punct_definition);
     }
   }
+
+  // Drop punctuator in words, to make temp_ascii works:
+  ctx->commit_history().clear();
   return kAccepted;
 }
 
-- 
2.39.5 (Apple Git-154)

