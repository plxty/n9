From 7da39185608a7683fafd62d93a7e32b8c59bdb9b Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Wed, 3 Dec 2025 16:13:55 +0800
Subject: [PATCH] colmena: hack

---
 .envrc                        |  2 +-
 src/cli.rs                    |  2 -
 src/command/apply.rs          | 17 +++++++
 src/command/apply_local.rs    | 54 +---------------------
 src/command/mod.rs            |  1 -
 src/nix/deployment/mod.rs     | 10 +++-
 src/nix/deployment/options.rs | 10 ++++
 src/nix/hive/mod.rs           |  2 +-
 src/nix/host/local.rs         | 40 +++++++++-------
 src/nix/host/mod.rs           | 34 ++++++--------
 src/nix/host/ssh.rs           | 86 ++++++++++++++++++-----------------
 src/nix/mod.rs                | 42 ++++++-----------
 src/nix/node_filter.rs        |  7 ++-
 src/nix/profile.rs            | 47 ++++++++++---------
 src/util.rs                   | 20 --------
 15 files changed, 166 insertions(+), 208 deletions(-)

diff --git a/.envrc b/.envrc
index de3998d..234e89d 100644
--- a/.envrc
+++ b/.envrc
@@ -2,4 +2,4 @@ if ! has nix_direnv_version || ! nix_direnv_version 2.1.1; then
   source_url "https://raw.githubusercontent.com/nix-community/nix-direnv/2.1.1/direnvrc" "sha256-b6qJ4r34rbE23yWjMqbmu3ia2z4b2wIlZUksBke/ol0="
 fi
 
-use flake
+use flake . --accept-flake-config
diff --git a/src/cli.rs b/src/cli.rs
index ab1d44c..66241cf 100644
--- a/src/cli.rs
+++ b/src/cli.rs
@@ -177,7 +177,6 @@ struct Opts {
 enum Command {
     Apply(command::apply::Opts),
 
-    #[cfg(target_os = "linux")]
     ApplyLocal(command::apply_local::Opts),
 
     /// Build configurations but not push to remote machines
@@ -330,7 +329,6 @@ pub async fn run() {
 
     match opts.command {
         Command::Apply(args) => r(command::apply::run(hive, args), opts.config).await,
-        #[cfg(target_os = "linux")]
         Command::ApplyLocal(args) => r(command::apply_local::run(hive, args), opts.config).await,
         Command::Eval(args) => r(command::eval::run(hive, args), opts.config).await,
         Command::Exec(args) => r(command::exec::run(hive, args), opts.config).await,
diff --git a/src/command/apply.rs b/src/command/apply.rs
index 0463367..640a810 100644
--- a/src/command/apply.rs
+++ b/src/command/apply.rs
@@ -45,6 +45,21 @@ pub struct DeployOpts {
     #[arg(short, long)]
     verbose: bool,
 
+    /// Sign the store
+    ///
+    /// Before uploading the closure, sign it first.
+    #[arg(
+        long,
+        help = "Sign nix store closure",
+        long_help = r#"Sign nix store closure with private key <SIGN> before pushing to the target node.
+
+When set, colmena will try to run `nix store sign` of the prof /ile.
+You may want to configure the target node to accept the public key with `nix.settings.trusted-public-keys`.
+
+This is identical to `services.nix-serve.secretKeyFile` in nix.conf, but more flexible."#
+    )]
+    sign: Option<String>,
+
     /// Do not upload keys
     ///
     /// By default, Colmena will upload secret keys set in `deployment.keys` before deploying
@@ -142,6 +157,7 @@ pub async fn run(hive: Hive, opts: Opts) -> Result<(), ColmenaError> {
                 keep_result,
                 verbose,
                 no_keys,
+                sign,
                 reboot,
                 no_substitute,
                 no_gzip,
@@ -184,6 +200,7 @@ pub async fn run(hive: Hive, opts: Opts) -> Result<(), ColmenaError> {
         options.set_substituters_push(!no_substitute);
         options.set_gzip(!no_gzip);
         options.set_upload_keys(!no_keys);
+        options.set_sign(sign);
         options.set_reboot(reboot);
         options.set_force_replace_unknown_profiles(force_replace_unknown_profiles);
         options.set_evaluator(evaluator);
diff --git a/src/command/apply_local.rs b/src/command/apply_local.rs
index fedb0de..12b9274 100644
--- a/src/command/apply_local.rs
+++ b/src/command/apply_local.rs
@@ -1,8 +1,6 @@
-use regex::Regex;
 use std::collections::HashMap;
 
 use clap::Args;
-use tokio::fs;
 
 use crate::error::ColmenaError;
 
@@ -22,10 +20,6 @@ pub struct Opts {
     #[arg(value_name = "GOAL", default_value_t)]
     goal: Goal,
 
-    /// Attempt to escalate privileges if not run as root
-    #[arg(long)]
-    sudo: bool,
-
     /// Be verbose
     ///
     /// Deactivates the progress spinner and prints every line of output.
@@ -42,50 +36,17 @@ pub struct Opts {
     /// Override the node name to use
     #[arg(long)]
     node: Option<String>,
-
-    /// Removed: Configure deployment.privilegeEscalationCommand in node configuration
-    #[arg(long, value_name = "COMMAND", hide = true)]
-    sudo_command: Option<String>,
 }
 
 pub async fn run(
     hive: Hive,
     Opts {
         goal,
-        sudo,
         verbose,
         no_keys,
         node,
-        sudo_command,
     }: Opts,
 ) -> Result<(), ColmenaError> {
-    if sudo_command.is_some() {
-        tracing::error!("--sudo-command has been removed. Please configure it in deployment.privilegeEscalationCommand in the node configuration.");
-        quit::with_code(1);
-    }
-
-    // Sanity check: Are we running NixOS?
-    if let Ok(os_release) = fs::read_to_string("/etc/os-release").await {
-        let re = Regex::new(r#"ID="?nixos"?"#).unwrap();
-        if !re.is_match(&os_release) {
-            tracing::error!("\"apply-local\" only works on NixOS machines.");
-            quit::with_code(5);
-        }
-    } else {
-        tracing::error!("Could not detect the OS version from /etc/os-release.");
-        quit::with_code(5);
-    }
-
-    let verbose = verbose || sudo; // cannot use spinners with interactive sudo
-
-    {
-        let euid: u32 = unsafe { libc::geteuid() };
-        if euid != 0 && !sudo {
-            tracing::warn!("Colmena was not started by root. This is probably not going to work.");
-            tracing::warn!("Hint: Add the --sudo flag.");
-        }
-    }
-
     let hostname = NodeName::new(node.unwrap_or_else(|| {
         hostname::get()
             .expect("Could not get hostname")
@@ -96,20 +57,7 @@ pub async fn run(
     let target = {
         if let Some(info) = hive.deployment_info_single(&hostname).await.unwrap() {
             let nix_options = hive.nix_flags_with_builders().await.unwrap();
-            if !info.allows_local_deployment() {
-                tracing::error!(
-                    "Local deployment is not enabled for host {}.",
-                    hostname.as_str()
-                );
-                tracing::error!("Hint: Set deployment.allowLocalDeployment to true.");
-                quit::with_code(2);
-            }
-            let mut host = LocalHost::new(nix_options);
-            if sudo {
-                let command = info.privilege_escalation_command().to_owned();
-                host.set_privilege_escalation_command(Some(command));
-            }
-
+            let host = LocalHost::new(nix_options, info.clone());
             TargetNode::new(hostname.clone(), Some(host.upcast()), info.clone())
         } else {
             tracing::error!(
diff --git a/src/command/mod.rs b/src/command/mod.rs
index cc6c8cb..07f9b9d 100644
--- a/src/command/mod.rs
+++ b/src/command/mod.rs
@@ -4,7 +4,6 @@ pub mod exec;
 pub mod nix_info;
 pub mod repl;
 
-#[cfg(target_os = "linux")]
 pub mod apply_local;
 
 #[cfg(debug_assertions)]
diff --git a/src/nix/deployment/mod.rs b/src/nix/deployment/mod.rs
index 131b9d2..44b4a8b 100644
--- a/src/nix/deployment/mod.rs
+++ b/src/nix/deployment/mod.rs
@@ -502,10 +502,12 @@ impl Deployment {
         // Build system profile
         let build_job = parent.create_job(JobType::Build, nodes.clone())?;
         let arc_self = self.clone();
+
+        let config = target.config.clone();
         let profile: Profile = build_job
             .run(|job| async move {
                 // FIXME: Remote builder?
-                let mut builder = LocalHost::new(arc_self.nix_options.clone()).upcast();
+                let mut builder = LocalHost::new(arc_self.nix_options.clone(), config).upcast();
                 builder.set_job(Some(job.clone()));
 
                 let profile = profile_drv.realize(&mut builder).await?;
@@ -552,6 +554,12 @@ impl Deployment {
 
                 let host = target.host.as_mut().unwrap();
                 host.set_job(Some(job.clone()));
+
+                // Sign the profile if needed (only ssh push needs it now):
+                if let Some(key) = &arc_self.options.sign {
+                    host.sign_closure(push_profile.as_store_path(), key).await?;
+                }
+
                 host.copy_closure(
                     push_profile.as_store_path(),
                     CopyDirection::ToRemote,
diff --git a/src/nix/deployment/options.rs b/src/nix/deployment/options.rs
index 936de4d..12e1e63 100644
--- a/src/nix/deployment/options.rs
+++ b/src/nix/deployment/options.rs
@@ -16,6 +16,10 @@ pub struct Options {
     /// Whether to upload keys when deploying.
     pub(super) upload_keys: bool,
 
+    /// Path to the sign key when deploying.
+    /// TODO: PathBuf?
+    pub(super) sign: Option<String>,
+
     /// Whether to reboot the hosts after activation.
     pub(super) reboot: bool,
 
@@ -65,6 +69,10 @@ impl Options {
         self.upload_keys = enable;
     }
 
+    pub fn set_sign(&mut self, sign: Option<String>) {
+        self.sign = sign;
+    }
+
     pub fn set_reboot(&mut self, enable: bool) {
         self.reboot = enable;
     }
@@ -91,6 +99,7 @@ impl Options {
         options
             .use_substitutes(self.substituters_push)
             .gzip(self.gzip)
+            .check_sigs(self.sign.is_some())
     }
 }
 
@@ -100,6 +109,7 @@ impl Default for Options {
             substituters_push: true,
             gzip: true,
             upload_keys: true,
+            sign: None,
             reboot: false,
             create_gc_roots: false,
             force_build_on_target: None,
diff --git a/src/nix/hive/mod.rs b/src/nix/hive/mod.rs
index 0fe40ea..9528027 100644
--- a/src/nix/hive/mod.rs
+++ b/src/nix/hive/mod.rs
@@ -486,7 +486,7 @@ impl Hive {
         matches!(self.path(), HivePath::Flake(_))
     }
 
-    fn nix_instantiate(&self, expression: &str) -> NixInstantiate {
+    fn nix_instantiate(&'_ self, expression: &str) -> NixInstantiate<'_> {
         NixInstantiate::new(self, expression.to_owned())
     }
 
diff --git a/src/nix/host/local.rs b/src/nix/host/local.rs
index 6ed0af2..d7e080a 100644
--- a/src/nix/host/local.rs
+++ b/src/nix/host/local.rs
@@ -8,7 +8,7 @@ use tokio::process::Command;
 use super::{key_uploader, CopyDirection, CopyOptions, Host};
 use crate::error::{ColmenaError, ColmenaResult};
 use crate::job::JobHandle;
-use crate::nix::{Goal, Key, NixFlags, Profile, StorePath, CURRENT_PROFILE, SYSTEM_PROFILE};
+use crate::nix::{Goal, Key, NixFlags, NodeConfig, Profile, StorePath};
 use crate::util::{CommandExecution, CommandExt};
 
 /// The local machine running Colmena.
@@ -19,15 +19,15 @@ use crate::util::{CommandExecution, CommandExt};
 pub struct Local {
     job: Option<JobHandle>,
     nix_options: NixFlags,
-    privilege_escalation_command: Option<Vec<String>>,
+    config: NodeConfig,
 }
 
 impl Local {
-    pub fn new(nix_options: NixFlags) -> Self {
+    pub fn new(nix_options: NixFlags, config: NodeConfig) -> Self {
         Self {
             job: None,
             nix_options,
-            privilege_escalation_command: None,
+            config,
         }
     }
 }
@@ -85,13 +85,19 @@ impl Host for Local {
 
         if goal.should_switch_profile() {
             let path = profile.as_path().to_str().unwrap();
-            self.make_privileged_command(&["nix-env", "--profile", SYSTEM_PROFILE, "--set", path])
-                .passthrough()
-                .await?;
+            self.make_privileged_command(&[
+                "nix-env",
+                "--profile",
+                self.config.profile_wide.as_str(),
+                "--set",
+                path,
+            ])
+            .passthrough()
+            .await?;
         }
 
         let command = {
-            let activation_command = profile.activation_command(goal).unwrap();
+            let activation_command = profile.activation_command(&self.config, goal).unwrap();
             self.make_privileged_command(&activation_command)
         };
 
@@ -104,7 +110,7 @@ impl Host for Local {
 
     async fn get_current_system_profile(&mut self) -> ColmenaResult<Profile> {
         let paths = Command::new("readlink")
-            .args(["-e", CURRENT_PROFILE])
+            .args(["-e", self.config.profile_current.as_str()])
             .capture_output()
             .await?;
 
@@ -124,7 +130,8 @@ impl Host for Local {
                 "-c",
                 &format!(
                     "readlink -e {} || readlink -e {}",
-                    SYSTEM_PROFILE, CURRENT_PROFILE
+                    self.config.profile_wide.as_str(),
+                    self.config.profile_current.as_str()
                 ),
             ])
             .capture_output()
@@ -146,10 +153,6 @@ impl Host for Local {
 }
 
 impl Local {
-    pub fn set_privilege_escalation_command(&mut self, command: Option<Vec<String>>) {
-        self.privilege_escalation_command = command;
-    }
-
     pub fn upcast(self) -> Box<dyn Host> {
         Box::new(self)
     }
@@ -183,8 +186,13 @@ impl Local {
     /// Constructs a command with privilege escalation.
     fn make_privileged_command<S: AsRef<str>>(&self, command: &[S]) -> Command {
         let mut full_command = Vec::new();
-        if let Some(esc) = &self.privilege_escalation_command {
-            full_command.extend(esc.iter().map(|s| s.as_str()));
+        if !self.config.privilege_escalation_command.is_empty() {
+            full_command.extend(
+                self.config
+                    .privilege_escalation_command
+                    .iter()
+                    .map(|s| s.as_str()),
+            );
         }
         full_command.extend(command.iter().map(|s| s.as_ref()));
 
diff --git a/src/nix/host/mod.rs b/src/nix/host/mod.rs
index 8ff44ad..3a966f4 100644
--- a/src/nix/host/mod.rs
+++ b/src/nix/host/mod.rs
@@ -25,6 +25,7 @@ pub struct CopyOptions {
     include_outputs: bool,
     use_substitutes: bool,
     gzip: bool,
+    check_sigs: bool,
 }
 
 #[derive(Clone, Debug)]
@@ -42,6 +43,7 @@ impl Default for CopyOptions {
             include_outputs: true,
             use_substitutes: true,
             gzip: true,
+            check_sigs: false,
         }
     }
 }
@@ -61,6 +63,11 @@ impl CopyOptions {
         self.gzip = val;
         self
     }
+
+    pub fn check_sigs(mut self, val: bool) -> Self {
+        self.check_sigs = val;
+        self
+    }
 }
 
 impl Default for RebootOptions {
@@ -89,6 +96,12 @@ impl RebootOptions {
 /// The underlying implementation must be Send and Sync.
 #[async_trait]
 pub trait Host: Send + Sync + std::fmt::Debug {
+    /// Sign a closure if required.
+    #[allow(unused_variables)]
+    async fn sign_closure(&mut self, closure: &StorePath, key: &String) -> ColmenaResult<()> {
+        Err(ColmenaError::Unsupported)
+    }
+
     /// Sends or receives the specified closure to the host
     ///
     /// The StorePath and its dependent paths will then exist on this host.
@@ -122,27 +135,6 @@ pub trait Host: Send + Sync + std::fmt::Debug {
         Ok(paths)
     }
 
-    /// Pushes and optionally activates a profile to the host.
-    async fn deploy(
-        &mut self,
-        profile: &Profile,
-        goal: Goal,
-        copy_options: CopyOptions,
-    ) -> ColmenaResult<()> {
-        self.copy_closure(
-            profile.as_store_path(),
-            CopyDirection::ToRemote,
-            copy_options,
-        )
-        .await?;
-
-        if goal.requires_activation() {
-            self.activate(profile, goal).await?;
-        }
-
-        Ok(())
-    }
-
     /// Uploads a set of keys to the host.
     ///
     /// If `require_ownership` is false, then the ownership of a key
diff --git a/src/nix/host/ssh.rs b/src/nix/host/ssh.rs
index 64ebb68..c1d6edd 100644
--- a/src/nix/host/ssh.rs
+++ b/src/nix/host/ssh.rs
@@ -12,27 +12,18 @@ use tokio::time::sleep;
 use super::{key_uploader, CopyDirection, CopyOptions, Host, RebootOptions};
 use crate::error::{ColmenaError, ColmenaResult};
 use crate::job::JobHandle;
-use crate::nix::{Goal, Key, Profile, StorePath, CURRENT_PROFILE, SYSTEM_PROFILE};
+use crate::nix::{Goal, Key, NodeConfig, Profile, StorePath};
 use crate::util::{CommandExecution, CommandExt};
 
 /// A remote machine connected over SSH.
 #[derive(Debug)]
 pub struct Ssh {
-    /// The username to use to connect.
-    user: Option<String>,
-
-    /// The hostname or IP address to connect to.
-    host: String,
-
-    /// The port to connect to.
-    port: Option<u16>,
+    /// Node config, just clone it, no much overheads
+    config: NodeConfig,
 
     /// Local path to a ssh_config file.
     ssh_config: Option<PathBuf>,
 
-    /// Command to elevate privileges with.
-    privilege_escalation_command: Vec<String>,
-
     /// extra SSH options
     extra_ssh_options: Vec<String>,
 
@@ -48,6 +39,23 @@ struct BootId(String);
 
 #[async_trait]
 impl Host for Ssh {
+    async fn sign_closure(&mut self, closure: &StorePath, key: &String) -> ColmenaResult<()> {
+        let mut command = Command::new("nix");
+
+        command.args([
+            "--extra-experimental-features",
+            "nix-command",
+            "store",
+            "sign",
+            "-k",
+            key,
+            "--recursive",
+            closure.as_path().to_str().unwrap(),
+        ]);
+
+        self.run_command(command).await
+    }
+
     async fn copy_closure(
         &mut self,
         closure: &StorePath,
@@ -97,11 +105,17 @@ impl Host for Ssh {
 
         if goal.should_switch_profile() {
             let path = profile.as_path().to_str().unwrap();
-            let set_profile = self.ssh(&["nix-env", "--profile", SYSTEM_PROFILE, "--set", path]);
+            let set_profile = self.ssh(&[
+                "nix-env",
+                "--profile",
+                self.config.profile_wide.as_str(),
+                "--set",
+                path,
+            ]);
             self.run_command(set_profile).await?;
         }
 
-        let activation_command = profile.activation_command(goal).unwrap();
+        let activation_command = profile.activation_command(&self.config, goal).unwrap();
         let v: Vec<&str> = activation_command.iter().map(|s| &**s).collect();
         let command = self.ssh(&v);
         self.run_command(command).await
@@ -109,7 +123,7 @@ impl Host for Ssh {
 
     async fn get_current_system_profile(&mut self) -> ColmenaResult<Profile> {
         let paths = self
-            .ssh(&["readlink", "-e", CURRENT_PROFILE])
+            .ssh(&["readlink", "-e", self.config.profile_current.as_str()])
             .capture_output()
             .await?;
 
@@ -126,7 +140,8 @@ impl Host for Ssh {
     async fn get_main_system_profile(&mut self) -> ColmenaResult<Profile> {
         let command = format!(
             "\"readlink -e {} || readlink -e {}\"",
-            SYSTEM_PROFILE, CURRENT_PROFILE
+            self.config.profile_wide.as_str(),
+            self.config.profile_current.as_str()
         );
 
         let paths = self.ssh(&["sh", "-c", &command]).capture_output().await?;
@@ -185,31 +200,20 @@ impl Host for Ssh {
 }
 
 impl Ssh {
-    pub fn new(user: Option<String>, host: String) -> Self {
+    pub fn new(config: NodeConfig) -> Self {
         Self {
-            user,
-            host,
-            port: None,
+            config,
             ssh_config: None,
-            privilege_escalation_command: Vec::new(),
             extra_ssh_options: Vec::new(),
             use_nix3_copy: false,
             job: None,
         }
     }
 
-    pub fn set_port(&mut self, port: u16) {
-        self.port = Some(port);
-    }
-
     pub fn set_ssh_config(&mut self, ssh_config: PathBuf) {
         self.ssh_config = Some(ssh_config);
     }
 
-    pub fn set_privilege_escalation_command(&mut self, command: Vec<String>) {
-        self.privilege_escalation_command = command;
-    }
-
     pub fn set_extra_ssh_options(&mut self, options: Vec<String>) {
         self.extra_ssh_options = options;
     }
@@ -226,8 +230,8 @@ impl Ssh {
     pub fn ssh(&self, command: &[&str]) -> Command {
         let options = self.ssh_options();
         let options_str = options.join(" ");
-        let privilege_escalation_command = if self.user.as_deref() != Some("root") {
-            self.privilege_escalation_command.as_slice()
+        let privilege_escalation_command = if self.config.target_user.as_deref() != Some("root") {
+            self.config.privilege_escalation_command.as_slice()
         } else {
             &[]
         };
@@ -252,9 +256,10 @@ impl Ssh {
     }
 
     fn ssh_target(&self) -> String {
-        match &self.user {
-            Some(n) => format!("{}@{}", n, self.host),
-            None => self.host.clone(),
+        let host = self.config.target_host.as_ref().unwrap();
+        match &self.config.target_user {
+            Some(n) => format!("{}@{}", n, host),
+            None => host.clone(),
         }
     }
 
@@ -271,12 +276,11 @@ impl Ssh {
             // experimental `nix copy` command with ssh-ng://
             let mut command = Command::new("nix");
 
-            command.args([
-                "--extra-experimental-features",
-                "nix-command",
-                "copy",
-                "--no-check-sigs",
-            ]);
+            command.args(["--extra-experimental-features", "nix-command", "copy"]);
+
+            if !options.check_sigs {
+                command.arg("--no-check-sigs");
+            }
 
             if options.use_substitutes {
                 command.args([
@@ -357,7 +361,7 @@ impl Ssh {
         .chain(self.extra_ssh_options.clone())
         .collect();
 
-        if let Some(port) = self.port {
+        if let Some(port) = self.config.target_port {
             options.push("-p".to_string());
             options.push(port.to_string());
         }
diff --git a/src/nix/mod.rs b/src/nix/mod.rs
index 7c8b9ed..61e85c0 100644
--- a/src/nix/mod.rs
+++ b/src/nix/mod.rs
@@ -42,12 +42,6 @@ pub mod evaluator;
 pub mod expression;
 pub use expression::{NixExpression, SerializedNixExpression};
 
-/// Path to the main system profile.
-pub const SYSTEM_PROFILE: &str = "/nix/var/nix/profiles/system";
-
-/// Path to the system profile that's currently active.
-pub const CURRENT_PROFILE: &str = "/run/current-system";
-
 /// A node's attribute name.
 #[derive(Serialize, Deserialize, Clone, Debug, Hash, Eq, PartialEq)]
 #[serde(transparent)]
@@ -64,8 +58,17 @@ pub struct NodeConfig {
     #[serde(rename = "targetPort")]
     target_port: Option<u16>,
 
-    #[serde(rename = "allowLocalDeployment")]
-    allow_local_deployment: bool,
+    #[serde(rename = "profileWide")]
+    profile_wide: String,
+
+    #[serde(rename = "profileCurrent")]
+    profile_current: String,
+
+    #[serde(rename = "activateScript")]
+    activate_script: String,
+
+    #[serde(rename = "switchGoal")]
+    switch_goal: Option<Vec<String>>,
 
     #[serde(rename = "buildOnTarget")]
     build_on_target: bool,
@@ -164,15 +167,6 @@ impl NodeConfig {
         &self.tags
     }
 
-    #[cfg_attr(not(target_os = "linux"), allow(dead_code))]
-    pub fn allows_local_deployment(&self) -> bool {
-        self.allow_local_deployment
-    }
-
-    pub fn privilege_escalation_command(&self) -> &Vec<String> {
-        &self.privilege_escalation_command
-    }
-
     pub fn build_on_target(&self) -> bool {
         self.build_on_target
     }
@@ -181,17 +175,9 @@ impl NodeConfig {
     }
 
     pub fn to_ssh_host(&self) -> Option<Ssh> {
-        self.target_host.as_ref().map(|target_host| {
-            let mut host = Ssh::new(self.target_user.clone(), target_host.clone());
-            host.set_privilege_escalation_command(self.privilege_escalation_command.clone());
-            host.set_extra_ssh_options(self.extra_ssh_options.clone());
-
-            if let Some(target_port) = self.target_port {
-                host.set_port(target_port);
-            }
-
-            host
-        })
+        let mut host = Ssh::new(self.clone());
+        host.set_extra_ssh_options(self.extra_ssh_options.clone());
+        Some(host)
     }
 }
 
diff --git a/src/nix/node_filter.rs b/src/nix/node_filter.rs
index af76196..dbe6b9f 100644
--- a/src/nix/node_filter.rs
+++ b/src/nix/node_filter.rs
@@ -237,12 +237,15 @@ mod tests {
     fn test_filter_node_configs() {
         // TODO: Better way to mock
         let template = NodeConfig {
-            tags: vec![],
             target_host: None,
             target_user: None,
             target_port: None,
-            allow_local_deployment: false,
+            profile_wide: String::new(),
+            profile_current: String::new(),
+            activate_script: String::new(),
+            switch_goal: None,
             build_on_target: false,
+            tags: vec![],
             replace_unknown_profiles: false,
             privilege_escalation_command: vec![],
             extra_ssh_options: vec![],
diff --git a/src/nix/profile.rs b/src/nix/profile.rs
index b71c637..92ece43 100644
--- a/src/nix/profile.rs
+++ b/src/nix/profile.rs
@@ -4,7 +4,9 @@ use std::process::Stdio;
 
 use tokio::process::Command;
 
-use super::{BuildResult, ColmenaError, ColmenaResult, Goal, StoreDerivation, StorePath};
+use super::{
+    BuildResult, ColmenaError, ColmenaResult, Goal, NodeConfig, StoreDerivation, StorePath,
+};
 
 pub type ProfileDerivation = StoreDerivation<Profile>;
 
@@ -13,31 +15,34 @@ pub type ProfileDerivation = StoreDerivation<Profile>;
 pub struct Profile(StorePath);
 
 impl Profile {
-    pub fn from_store_path(path: StorePath) -> ColmenaResult<Self> {
-        if !path.is_dir() || !path.join("bin/switch-to-configuration").exists() {
-            return Err(ColmenaError::InvalidProfile);
+    /// Returns the command to activate this profile.
+    pub fn activation_command(&self, config: &NodeConfig, goal: Goal) -> Option<Vec<String>> {
+        if config.switch_goal.is_some() && !goal.should_switch_profile() {
+            tracing::error!("Profile's switchGoal defined non-null, {:?} != switch", goal);
+            return None;
         }
 
-        if path.to_str().is_none() {
-            Err(ColmenaError::InvalidProfile)
+        let goal = match goal.as_str() {
+            Some(goal) => goal,
+            None => return None,
+        };
+
+        let activate = match self.as_path().join(config.activate_script.as_str()) {
+            path if path.exists() => path,
+            _ => {
+                tracing::error!("Activate script {} does not exist", config.activate_script);
+                return None;
+            }
+        };
+
+        let mut activate = vec![activate.to_str().unwrap().to_string()];
+        if config.switch_goal.is_some() {
+            activate.append(&mut config.switch_goal.as_ref().unwrap().clone());
         } else {
-            Ok(Self(path))
+            activate.push(goal.to_string());
         }
-    }
 
-    /// Returns the command to activate this profile.
-    pub fn activation_command(&self, goal: Goal) -> Option<Vec<String>> {
-        if let Some(goal) = goal.as_str() {
-            let path = self.as_path().join("bin/switch-to-configuration");
-            let switch_to_configuration = path
-                .to_str()
-                .expect("The string should be UTF-8 valid")
-                .to_string();
-
-            Some(vec![switch_to_configuration, goal.to_string()])
-        } else {
-            None
-        }
+        Some(activate)
     }
 
     /// Returns the store path.
diff --git a/src/util.rs b/src/util.rs
index ffbfef5..eb4abe5 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -1,5 +1,3 @@
-use std::convert::TryFrom;
-
 use std::process::Stdio;
 
 use async_trait::async_trait;
@@ -11,7 +9,6 @@ use tokio::process::Command;
 use super::error::{ColmenaError, ColmenaResult};
 use super::job::JobHandle;
 use super::nix::deployment::TargetNodeMap;
-use super::nix::StorePath;
 
 const NEWLINE: u8 = 0xa;
 
@@ -37,9 +34,6 @@ pub trait CommandExt {
     async fn capture_json<T>(&mut self) -> ColmenaResult<T>
     where
         T: DeserializeOwned;
-
-    /// Runs the command, capturing a single store path.
-    async fn capture_store_path(&mut self) -> ColmenaResult<StorePath>;
 }
 
 impl CommandExecution {
@@ -149,13 +143,6 @@ impl CommandExt for Command {
             output: output.clone(),
         })
     }
-
-    /// Captures a single store path.
-    async fn capture_store_path(&mut self) -> ColmenaResult<StorePath> {
-        let output = self.capture_output().await?;
-        let path = output.trim_end().to_owned();
-        StorePath::try_from(path)
-    }
 }
 
 #[async_trait]
@@ -182,13 +169,6 @@ impl CommandExt for CommandExecution {
             output: output.clone(),
         })
     }
-
-    /// Captures a single store path.
-    async fn capture_store_path(&mut self) -> ColmenaResult<StorePath> {
-        let output = self.capture_output().await?;
-        let path = output.trim_end().to_owned();
-        StorePath::try_from(path)
-    }
 }
 
 pub async fn capture_stream<R>(
-- 
2.50.1

