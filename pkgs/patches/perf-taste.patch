From 3af448fa93f81595222c87ab3f608e2aea195c5a Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Fri, 12 Dec 2025 17:03:35 +0800
Subject: [PATCH] tools: perf: cache dwarf

---
 tools/perf/util/thread.c       |  2 +
 tools/perf/util/thread.h       |  7 ++++
 tools/perf/util/unwind-libdw.c | 76 +++++++++++++++++++++++++---------
 tools/perf/util/unwind-libdw.h |  2 +-
 tools/perf/util/unwind.h       |  3 ++
 5 files changed, 69 insertions(+), 21 deletions(-)

diff --git a/tools/perf/util/thread.c b/tools/perf/util/thread.c
index aa9c58bbf9d32..13020d1b4245e 100644
--- a/tools/perf/util/thread.c
+++ b/tools/perf/util/thread.c
@@ -72,6 +72,7 @@ struct thread *thread__new(pid_t pid, pid_t tid)
 		/* Thread holds first ref to nsdata. */
 		RC_CHK_ACCESS(thread)->nsinfo = nsinfo__new(pid);
 		srccode_state_init(thread__srccode_state(thread));
+		unwind__new(thread);
 	}
 
 	return thread;
@@ -118,6 +119,7 @@ void thread__delete(struct thread *thread)
 
 	nsinfo__zput(RC_CHK_ACCESS(thread)->nsinfo);
 	srccode_state_free(thread__srccode_state(thread));
+	unwind__delete(thread);
 
 	exit_rwsem(thread__namespaces_lock(thread));
 	exit_rwsem(thread__comm_lock(thread));
diff --git a/tools/perf/util/thread.h b/tools/perf/util/thread.h
index 310eaea344bbc..aae1da74ee0f9 100644
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@ -68,6 +68,13 @@ DECLARE_RC_STRUCT(thread) {
 	/* LBR call stack stitch */
 	bool			lbr_stitch_enable;
 	struct lbr_stitch	*lbr_stitch;
+
+	/**
+	 * @callchain_state: Cached state for callchains, e.g. dwarf.
+	 * For compressed debug info, extract them every time is costly.
+	 * TODO: Add thread__helpers?
+	 */
+	void *callchain_state;
 };
 
 struct machine;
diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index ae70fb56a0572..b2ee6c181120b 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -260,39 +260,70 @@ frame_callback(Dwfl_Frame *state, void *arg)
 	       DWARF_CB_ABORT : DWARF_CB_OK;
 }
 
+int unwind__new(struct thread *thread)
+{
+	struct unwind_info *ui;
+
+	ui = zalloc(sizeof(*ui));
+	if (!ui)
+		return -ENOMEM;
+
+	ui->dwfl = dwfl_begin(&offline_callbacks);
+	if (!ui->dwfl) {
+		free(ui);
+		return -ENOMEM;
+	}
+
+	thread->callchain_state = ui;
+	return 0;
+}
+
+void unwind__delete(struct thread *thread)
+{
+	struct unwind_info *ui;
+
+	ui = thread->callchain_state;
+	if (!ui)
+		return;
+
+	if (ui->dwfl)
+		dwfl_end(ui->dwfl);
+
+	free(ui);
+}
+
 int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 			struct thread *thread,
 			struct perf_sample *data,
 			int max_stack,
 			bool best_effort)
 {
-	struct unwind_info *ui, ui_buf = {
-		.sample		= data,
-		.thread		= thread,
-		.machine	= maps__machine((thread__maps(thread))),
-		.cb		= cb,
-		.arg		= arg,
-		.max_stack	= max_stack,
-		.best_effort    = best_effort
-	};
-	const char *arch = perf_env__arch(ui_buf.machine->env);
+	struct unwind_info *ui;
 	Dwarf_Word ip;
 	int err = -EINVAL, i;
 
 	if (!data->user_regs || !data->user_regs->regs)
 		return -EINVAL;
 
-	ui = zalloc(sizeof(ui_buf) + sizeof(ui_buf.entries[0]) * max_stack);
+	ui = thread->callchain_state;
 	if (!ui)
 		return -ENOMEM;
+	*ui = (struct unwind_info){
+		.dwfl		= ui->dwfl,
+		.sample		= data,
+		.thread		= thread,
+		.machine	= maps__machine((thread__maps(thread))),
+		.cb		= cb,
+		.arg		= arg,
+		.max_stack	= max_stack,
+		.best_effort    = best_effort,
+	};
 
-	*ui = ui_buf;
-
-	ui->dwfl = dwfl_begin(&offline_callbacks);
-	if (!ui->dwfl)
-		goto out;
+	ui->entries = zalloc(sizeof(*ui->entries) * max_stack);
+	if (!ui->entries)
+		return -ENOMEM;
 
-	err = perf_reg_value(&ip, data->user_regs, perf_arch_reg_ip(arch));
+	err = perf_reg_value(&ip, data->user_regs, perf_arch_reg_ip(perf_env__arch(ui->machine->env)));
 	if (err)
 		goto out;
 
@@ -300,10 +331,16 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 	if (err)
 		goto out;
 
+	// We attach to the dwfl only once, reling on callbacks to unwind:
+	// FIXME: If thread changes? For example, exec?
+	if (dwfl_pid(ui->dwfl) == thread__tid(thread))
+		goto unwind;
+
 	err = !dwfl_attach_state(ui->dwfl, EM_NONE, thread__tid(thread), &callbacks, ui);
 	if (err)
 		goto out;
 
+unwind:
 	err = dwfl_getthread_frames(ui->dwfl, thread__tid(thread), frame_callback, ui);
 
 	if (err && ui->max_stack != max_stack)
@@ -323,9 +360,8 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 
  out:
 	if (err)
-		pr_debug("unwind: failed with '%s'\n", dwfl_errmsg(-1));
+		pr_err("unwind: failed with '%s'\n", dwfl_errmsg(-1));
 
-	dwfl_end(ui->dwfl);
-	free(ui);
+	free(ui->entries);
 	return 0;
 }
diff --git a/tools/perf/util/unwind-libdw.h b/tools/perf/util/unwind-libdw.h
index 8c88bc4f2304b..870bafc28c8bb 100644
--- a/tools/perf/util/unwind-libdw.h
+++ b/tools/perf/util/unwind-libdw.h
@@ -21,7 +21,7 @@ struct unwind_info {
 	int			max_stack;
 	int			idx;
 	bool			best_effort;
-	struct unwind_entry	entries[];
+	struct unwind_entry	*entries;
 };
 
 #endif /* __PERF_UNWIND_LIBDW_H */
diff --git a/tools/perf/util/unwind.h b/tools/perf/util/unwind.h
index 9f7164c6d9aa9..83eb739ad8199 100644
--- a/tools/perf/util/unwind.h
+++ b/tools/perf/util/unwind.h
@@ -27,6 +27,9 @@ struct unwind_libunwind_ops {
 };
 
 #ifdef HAVE_DWARF_UNWIND_SUPPORT
+/* cached resources for unwind; FIXME: consider exec with same tid? */
+int unwind__new(struct thread *thread);
+void unwind__delete(struct thread *thread);
 /*
  * When best_effort is set, don't report errors and fail silently. This could
  * be expanded in the future to be more permissive about things other than
-- 
2.51.2

