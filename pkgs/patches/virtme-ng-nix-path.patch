diff --git a/src/main.rs b/src/main.rs
index 895ad42..a364e05 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-3.0
 
 //! virtme-ng-init
+//! git diff src/main.rs | sed -E 's$(a|b)/virtme_ng_init/src$\1/src$g'
 //!
 //! This program serves as an extremely lightweight init process for `virtme-ng` in order to speed
 //! up boot time.
@@ -21,7 +22,7 @@ use nix::sys::stat::Mode;
 use nix::sys::utsname::uname;
 use nix::unistd::sethostname;
 use std::env;
-use std::fs::{File, OpenOptions};
+use std::fs::{create_dir_all, File, OpenOptions};
 use std::io::{self, BufRead, BufReader, BufWriter, Write};
 use std::os::fd::{AsRawFd, IntoRawFd};
 use std::os::unix::process::CommandExt;
@@ -66,6 +67,13 @@ const KERNEL_MOUNTS: &[MountInfo] = &[
         flags: 0,
         fsdata: "mode=0755",
     },
+    MountInfo {
+        source: "tmp",
+        target: "/tmp",
+        fs_type: "tmpfs",
+        flags: 0,
+        fsdata: "mode=0755",
+    },
     MountInfo {
         source: "devtmpfs",
         target: "/dev",
@@ -205,8 +213,72 @@ fn poweroff() {
     }
 }
 
-fn configure_environment() {
-    env::set_var("PATH", "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin");
+struct NixOSHost {
+    current_system: PathBuf,
+    wrapper_dir: Option<String>,
+    wrappers_script: Option<String>,
+}
+
+enum Host {
+    Linux,
+    NixOS(NixOSHost),
+}
+
+impl Host {
+    fn post_configure(&self) {
+        if let Self::NixOS(host) = self {
+            // Before we move on, Inherit some configurations from a NixOS host:
+            utils::do_symlink(host.current_system.to_str().unwrap(), "/run/current-system");
+            if let Some(dir) = &host.wrapper_dir {
+                utils::do_mkdir(dir.as_str());
+            }
+            if let Some(exec) = &host.wrappers_script {
+                utils::run_cmd(exec, &[]);
+            }
+        }
+    }
+}
+
+fn configure_environment() -> Host {
+    let nix_includes = include_str!("nix-path");
+
+    let current_system = std::fs::read_link("/run/current-system");
+    if current_system.is_err() {
+        // Fallback to normal Linux:
+        env::set_var(
+            "PATH",
+            format!("{nix_includes}:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin"),
+        );
+        return Host::Linux;
+    }
+
+    // If NixOS, @see /run/current-system/{init,activate}
+    // PATH will get updated when bash profile is sourced, we just need what init really needs here.
+    // TODO: Pass path from host env, instead of hardcoded nix-path file.
+    env::set_var(
+        "PATH",
+        format!("{nix_includes}:/run/wrappers/bin:/run/current-system/sw/bin"),
+    );
+
+    // setup security wrappers, for sudo things to work:
+    let mut wrapper_dir = None;
+    let mut wrappers_script = None;
+    for line in std::fs::read_to_string("/etc/systemd/system/suid-sgid-wrappers.service")
+        .unwrap()
+        .lines()
+    {
+        if let Some(dir) = line.strip_prefix("RequiresMountsFor=") {
+            wrapper_dir = Some(dir.trim_end().to_string());
+        } else if let Some(exec) = line.strip_prefix("ExecStart=") {
+            wrappers_script = Some(exec.trim_end().to_string());
+        }
+    }
+
+    Host::NixOS(NixOSHost {
+        current_system: current_system.unwrap(),
+        wrapper_dir,
+        wrappers_script,
+    })
 }
 
 fn get_kernel_version(show_machine: bool) -> String {
@@ -304,12 +376,38 @@ fn generate_shadow() -> io::Result<()> {
 
     let reader = BufReader::new(input_file);
     let mut writer = BufWriter::new(output_file);
+    let mut sshd_user = false;
 
     for line in reader.lines() {
         if let Some((username, _)) = line?.split_once(':') {
+            if username == "sshd" {
+                sshd_user = true;
+            }
             writeln!(writer, "{username}:!:::::::")?;
         }
     }
+
+    // For sshd + root, we should create a new user called sshd to make privilege separation works.
+    if let Ok(username) = env::var("virtme_ssh_user") {
+        if username == "root" && !sshd_user {
+            std::fs::copy("/etc/passwd", "/run/tmp/passwd")?;
+            let mut passwd = std::fs::OpenOptions::new()
+                .write(true)
+                .append(true)
+                .open("/run/tmp/passwd")?;
+            writeln!(passwd, "sshd:x:109:65534::/run/sshd:/bin/false");
+            writeln!(writer, "sshd:!:::::::")?;
+
+            utils::do_mount(
+                "/run/tmp/passwd",
+                "/etc/passwd",
+                "",
+                libc::MS_BIND as usize,
+                "",
+            );
+        }
+    }
+
     utils::do_mount(
         "/run/tmp/shadow",
         "/etc/shadow",
@@ -323,7 +421,7 @@ fn generate_shadow() -> io::Result<()> {
 
 fn generate_sudoers() -> io::Result<()> {
     let fname = "/run/tmp/sudoers";
-    let mut content = "Defaults secure_path=\"/usr/sbin:/usr/bin:/sbin:/bin\"\n".to_string();
+    let mut content = String::new();
     content += "root ALL = (ALL) NOPASSWD: ALL\n";
     if let Ok(user) = env::var("virtme_user") {
         content += &format!("{user} ALL = (ALL) NOPASSWD: ALL\n");
@@ -474,7 +572,8 @@ fn mount_virtme_overlays() {
 fn mount_virtme_initmounts() {
     for (key, path) in env::vars() {
         if key.starts_with("virtme_initmount") {
-            utils::do_mkdir(&path);
+            // TODO: Make util::do_mkdir supports recursive.
+            create_dir_all(&path).expect("failed to create dir for initmounts");
             utils::do_mount(
                 &key.replace('_', "."),
                 &path,
@@ -576,9 +675,20 @@ fn find_udevd() -> Option<PathBuf> {
     let path = env::var("PATH").unwrap_or_else(|_| String::new());
     let path_candidates = path.split(':').map(|dir| Path::new(dir).join("udevd"));
 
+    let mut service_candidates = vec![];
+    if let Ok(content) = std::fs::read_to_string("/etc/systemd/system/systemd-udevd.service") {
+        for line in content.lines() {
+            if let Some(exec) = line.strip_prefix("ExecStart=") {
+                service_candidates.push(PathBuf::from(exec.trim_end()));
+                break;
+            }
+        }
+    }
+
     static_candidates
         .into_iter()
         .chain(path_candidates)
+        .chain(service_candidates)
         .find(|path| path.exists())
 }
 
@@ -911,7 +1021,7 @@ fn run_user_gui(tty_fd: libc::c_int) {
     if let Err(err) = utils::create_file(
         xinitrc,
         0o0644,
-        &format!("{pre_exec_cmd}\n/bin/bash {USER_SCRIPT}"),
+        &format!("{pre_exec_cmd}\n/usr/bin/env bash {USER_SCRIPT}"),
     ) {
         log!("failed to generate {}: {}", xinitrc, err);
         return;
@@ -1078,7 +1188,6 @@ fn setup_socat_console() {
 fn run_misc_services() -> thread::JoinHandle<()> {
     thread::spawn(|| {
         symlink_fds();
-        mount_virtme_initmounts();
         fix_packaging_files();
         override_system_files();
         run_sshd();
@@ -1101,14 +1210,18 @@ fn print_logo() {
 
 fn main() {
     // Basic system initialization (order is important here).
-    configure_environment();
+    let host = configure_environment();
     configure_hostname();
     mount_kernel_filesystems();
     mount_cgroupfs();
     configure_limits();
+
+    // The overlays may relies on initmounts, e.g. for --root
+    mount_virtme_initmounts();
     mount_virtme_overlays();
     mount_sys_filesystems();
     mount_kernel_modules();
+    host.post_configure();
     run_systemd_tmpfiles();
 
     // Service running in the background for later
