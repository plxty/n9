From f3f747b35e54ba6399611e546f3a9640ae672495 Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Tue, 2 Dec 2025 23:11:54 +0800
Subject: [PATCH] mihomo: hack

---
 .gitignore                       |  4 +-
 README.md                        | 57 ++++++++++++++++++++
 component/fakeip/skipper.go      | 26 +++++----
 component/fakeip/skipper_test.go | 35 ++++++++++++-
 config/config.go                 | 90 ++++++++++++++++++++++++++++++++
 5 files changed, 200 insertions(+), 12 deletions(-)

diff --git a/.gitignore b/.gitignore
index d8801262..7085a92d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,4 +25,6 @@ vendor
 test/config/cache*
 /output
 .vscode/
-.fleet/
\ No newline at end of file
+.fleet/
+.envrc
+.direnv/
diff --git a/README.md b/README.md
index 05f03799..50ff45e0 100644
--- a/README.md
+++ b/README.md
@@ -30,6 +30,63 @@
 - Netfilter TCP redirecting. Deploy Mihomo on your Internet gateway with `iptables`.
 - Comprehensive HTTP RESTful API controller
 
+## Hacks
+
+* Yaml config can now support prepend/append, e.g.
+
+```yaml
+rules:
+  - DOMAIN-SUFFIX,google.com,PROXY
+  - DOMAIN-SUFFIX,github.com,PROXY
+
+dns:
+  fake-ip-filter:
+    - +.gov.cn
+    - +.edu.cn
+
+# Prepend:
++rules:
+  - DOMAIN-SUFFIX,gnu.org,PROXY
+
+dns.+fake-ip-filter:
+  - +.ac.cn
+
+# Append:
+rules+:
+  - DOMAIN-SUFFIX,kernel.org,PROXY
+
+dns.fake-ip-filter+:
+  - +.gd.cn
+```
+
+* Support `dns.fake-ip-reverse` configuration, it has higher priority and match the opposite of `dns.fake-ip-filter`, e.g.
+
+```yaml
+dns:
+  # Blacklist: these matched domains will not return faked ip:
+  fake-ip-filter-mode: blacklist
+  fake-ip-filter:
+    - +.cn
+  # BUT, following "reverse" will force these domains return faked ip:
+  fake-ip-reverse:
+    - +.googleapis.cn
+  # Result:
+  #  nslookup google.cn => real_ip
+  #  nslookup services.googleapis.cn => fake_ip
+
+dns:
+  # Whitelist: only these matched domains will return faked ip:
+  fake-ip-filter-mode: whitelist
+  fake-ip-filter:
+    - geosite:gfw
+  # BUT, following "reverse" will not let these domains return faked ip:
+  fake-ip-reverse:
+    - +.github.com
+  # Result:
+  #  nslookup google.com => fake_ip
+  #  nslookup github.com => real_ip
+```
+
 ## Dashboard
 
 A web dashboard with first-class support for this project has been created; it can be checked out at [metacubexd](https://github.com/MetaCubeX/metacubexd).
diff --git a/component/fakeip/skipper.go b/component/fakeip/skipper.go
index 2df4094a..a85d6525 100644
--- a/component/fakeip/skipper.go
+++ b/component/fakeip/skipper.go
@@ -5,24 +5,30 @@ import (
 )
 
 type Skipper struct {
-	Host []C.DomainMatcher
-	Mode C.FilterMode
+	Host    []C.DomainMatcher
+	Mode    C.FilterMode
+	Reverse []C.DomainMatcher
 }
 
 // ShouldSkipped return if domain should be skipped
 func (p *Skipper) ShouldSkipped(domain string) bool {
-	should := p.shouldSkipped(domain)
-	if p.Mode == C.FilterWhiteList {
-		return !should
+	// In blacklist mode, we skip matched item, but in whitelist, we can't:
+	skipMatched := p.Mode == C.FilterBlackList
+
+	// We have a higher priority matching, check it:
+	for _, matcher := range p.Reverse {
+		if matcher.MatchDomain(domain) {
+			// Blacklist (expect true), Reversed to Whitelist, expecting false
+			// Whitelist (expect false), Reversed to Blacklist, expecting true
+			return !skipMatched
+		}
 	}
-	return should
-}
 
-func (p *Skipper) shouldSkipped(domain string) bool {
 	for _, matcher := range p.Host {
 		if matcher.MatchDomain(domain) {
-			return true
+			return skipMatched
 		}
 	}
-	return false
+
+	return !skipMatched /* aka. skipUnmatched */
 }
diff --git a/component/fakeip/skipper_test.go b/component/fakeip/skipper_test.go
index 3ffffee9..ba4f503b 100644
--- a/component/fakeip/skipper_test.go
+++ b/component/fakeip/skipper_test.go
@@ -18,7 +18,7 @@ func TestSkipper_BlackList(t *testing.T) {
 	}
 	assert.True(t, skipper.ShouldSkipped("example.com"))
 	assert.False(t, skipper.ShouldSkipped("foo.com"))
-	assert.False(t, skipper.shouldSkipped("baz.com"))
+	assert.False(t, skipper.ShouldSkipped("baz.com"))
 }
 
 func TestSkipper_WhiteList(t *testing.T) {
@@ -33,3 +33,36 @@ func TestSkipper_WhiteList(t *testing.T) {
 	assert.True(t, skipper.ShouldSkipped("foo.com"))
 	assert.True(t, skipper.ShouldSkipped("baz.com"))
 }
+
+func testReverse(t *testing.T, mode C.FilterMode) {
+	tree := trie.New[struct{}]()
+	assert.NoError(t, tree.Insert("+.net", struct{}{}))
+	assert.False(t, tree.IsEmpty())
+	skipper := &Skipper{
+		Host: []C.DomainMatcher{tree.NewDomainSet()},
+		Mode: mode,
+	}
+
+	reverse := trie.New[struct{}]()
+	assert.NoError(t, reverse.Insert("test.net", struct{}{}))
+	assert.False(t, reverse.IsEmpty())
+	var matcher C.DomainMatcher = reverse.NewDomainSet()
+
+	if mode == C.FilterBlackList {
+		skipper.Reverse = append(skipper.Reverse, matcher)
+		assert.False(t, skipper.ShouldSkipped("test.net"))
+		assert.True(t, skipper.ShouldSkipped("only.net"))
+	} else {
+		skipper.Reverse = append(skipper.Reverse, matcher)
+		assert.True(t, skipper.ShouldSkipped("test.net"))
+		assert.False(t, skipper.ShouldSkipped("only.net"))
+	}
+}
+
+func TestSkipper_BlackListReverse(t *testing.T) {
+	testReverse(t, C.FilterBlackList)
+}
+
+func TestSkipper_WhitelistReverse(t *testing.T) {
+	testReverse(t, C.FilterWhiteList)
+}
diff --git a/config/config.go b/config/config.go
index 301126a6..3fe95563 100644
--- a/config/config.go
+++ b/config/config.go
@@ -230,6 +230,7 @@ type RawDNS struct {
 	FakeIPFilter                 []string                            `yaml:"fake-ip-filter" json:"fake-ip-filter"`
 	FakeIPFilterMode             C.FilterMode                        `yaml:"fake-ip-filter-mode" json:"fake-ip-filter-mode"`
 	FakeIPTTL                    int                                 `yaml:"fake-ip-ttl" json:"fake-ip-ttl"`
+	FakeIPReverse                []string                            `yaml:"fake-ip-reverse" json:"fake-ip-reverse"`
 	DefaultNameserver            []string                            `yaml:"default-nameserver" json:"default-nameserver"`
 	CacheAlgorithm               string                              `yaml:"cache-algorithm" json:"cache-algorithm"`
 	CacheMaxSize                 int                                 `yaml:"cache-max-size" json:"cache-max-size"`
@@ -515,6 +516,7 @@ func DefaultRawConfig() *RawConfig {
 				"www.msftconnecttest.com",
 			},
 			FakeIPFilterMode: C.FilterBlackList,
+			FakeIPReverse:    []string{},
 		},
 		NTP: RawNTP{
 			Enable:        false,
@@ -585,7 +587,67 @@ func DefaultRawConfig() *RawConfig {
 	}
 }
 
+func tryAppend(node map[string]interface{}) {
+	// Due to limitation of yaml, we can't have duplicate keys, therefore all
+	//  nested keys must represent as "a.b.c+" format.
+	// And for this limitation, we only loop one level, no recursion.
+	for k, v := range node {
+		switch v.(type) {
+		/*
+			case map[string]interface{}:
+				tryAppend(v.(map[string]interface{}))
+				continue
+		*/
+		case []interface{}:
+			prefixes := strings.Split(k, ".")
+			key := prefixes[len(prefixes)-1]
+			prefixes = prefixes[:len(prefixes)-1]
+			isPrepend := false
+
+			// "a.b.+c" or "a.b.c+":
+			if strings.HasPrefix(key, "+") {
+				key = key[1:]
+				isPrepend = true
+			} else if strings.HasSuffix(key, "+") {
+				key = key[:len(key)-1]
+			} else {
+				continue
+			}
+
+			// Fetch the real value:
+			lastNode := node
+			for len(prefixes) != 0 {
+				lastNode = lastNode[prefixes[0]].(map[string]interface{})
+				prefixes = prefixes[1:]
+			}
+
+			// TODO: Optimize:
+			values := lastNode[key].([]interface{})
+			appendValues := v.([]interface{})
+			if isPrepend {
+				lastNode[key] = append(appendValues, values...)
+			} else {
+				lastNode[key] = append(values, appendValues...)
+			}
+		}
+	}
+}
+
 func UnmarshalRawConfig(buf []byte) (*RawConfig, error) {
+	node := new(map[string]interface{})
+	if err := yaml.Unmarshal(buf, node); err != nil {
+		return nil, err
+	}
+
+	// Find append:
+	tryAppend(*node)
+
+	// Re-marshal to verify the appended, and to reload the final config:
+	buf, err := yaml.Marshal(node)
+	if err != nil {
+		return nil, err
+	}
+
 	// config with default value
 	rawCfg := DefaultRawConfig()
 
@@ -593,6 +655,14 @@ func UnmarshalRawConfig(buf []byte) (*RawConfig, error) {
 		return nil, err
 	}
 
+	/*
+		// Re-dump the final configurations, for debugging only:
+		buf, err = yaml.Marshal(rawCfg)
+		if err == nil {
+			log.Infoln("\t===== YAML START =====\n%s\t===== YAML   END =====", buf)
+		}
+	*/
+
 	return rawCfg, nil
 }
 
@@ -1460,6 +1530,26 @@ func parseDNS(rawCfg *RawConfig, ruleProviders map[string]P.RuleProvider) (*DNS,
 			Host: host,
 			Mode: cfg.FakeIPFilterMode,
 		}
+
+		/**
+		 * Reverse has higher priority, it filp the result.
+		 * e.g.
+		 *  fake-ip-filter:
+		 *   - +.cn
+		 *  fake-ip-filter-mode: blacklist
+		 *  fake-ip-reverse:
+		 *   - mistake.cn
+		 * Results `mistake.cn` get "whitelisted", i.e. it will be faked ip.
+		 * Works in the same manner of `whitelist` mode.
+		 */
+		if len(cfg.FakeIPReverse) != 0 {
+			reverse, err := parseDomain(cfg.FakeIPReverse, nil, "dns.fake-ip-reverse", ruleProviders)
+			if err != nil {
+				return nil, err
+			}
+			skipper.Reverse = reverse
+		}
+
 		dnsCfg.FakeIPSkipper = skipper
 		dnsCfg.FakeIPTTL = cfg.FakeIPTTL
 
-- 
2.50.1

