From 28d2b9d869cc9ed9241cdbe1c8fe767d0840d509 Mon Sep 17 00:00:00 2001
From: Zigit Zo <byte@kei.network>
Date: Fri, 5 Dec 2025 00:33:24 +0800
Subject: [PATCH] virtme-ng: hack

---
 .gitignore                        |   3 +
 virtme/commands/run.py            |  23 +++---
 virtme/guest/virtme-snapd-script  |   2 +-
 virtme/guest/virtme-sound-script  |   2 +-
 virtme/guest/virtme-sshd-script   |  14 +++-
 virtme/guest/virtme-udhcpc-script |   2 +-
 virtme_ng/run.py                  |   4 +
 virtme_ng_init/src/main.rs        | 118 ++++++++++++++++++++++++++++--
 8 files changed, 141 insertions(+), 27 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8ddd3fd..adb589f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,3 +19,6 @@ debian/virtme-ng.substvars
 virtme_ng_init/target
 virtme/guest/.crate*
 virtme/guest/bin
+.envrc
+.direnv/
+.helix/
diff --git a/virtme/commands/run.py b/virtme/commands/run.py
index a956de5..06657e7 100644
--- a/virtme/commands/run.py
+++ b/virtme/commands/run.py
@@ -20,6 +20,7 @@ import sys
 import tempfile
 import termios
 from base64 import b64encode
+from glob import glob
 from pathlib import Path
 from shutil import which
 from time import sleep
@@ -1017,7 +1018,7 @@ def console_client(args):
     with open(console_script_path, "w", encoding="utf-8") as file:
         print(
             (
-                "#! /bin/bash\n"
+                "#!/usr/bin/env bash\n"
                 "main() {\n"
                 f"{stty}\n"
                 f'HOME=$(getent passwd "{user}" | cut -d: -f6)\n'
@@ -1135,6 +1136,14 @@ def ssh_server(args, arch, qemuargs, kernelargs):
         ]
     )
 
+    # Try to locate a (one) pubkey, for ssh server to use:
+    # TODO: Make a temporary key with ssh-keygen, use that key only?
+    for pubkey in glob(os.path.expanduser("~/.ssh/id_*.pub")):
+        with open(pubkey) as reader:
+            content = reader.readline().strip()
+        kernelargs.append(f"virtme_ssh_pubkey={content}")
+        break
+
     ssh_proxy = os.path.realpath(resources.find_script("virtme-ssh-proxy"))
     with open(SSH_CONF_FILE, "w", encoding="utf-8") as f:
         f.write(f"""Host {VIRTME_SSH_DESTINATION_NAME}*
@@ -1437,17 +1446,7 @@ def do_it() -> int:
         # Check if paths are accessible both on the host and the guest.
         if not os.path.exists(hostpath):
             arg_fail(f"error: cannot access {hostpath} on the host")
-        # Guest path must be defined inside one of the overlays
-        guest_path_ok = False
-        for d in args.overlay_rwdir:
-            if os.path.exists(guestpath) or is_subpath(guestpath, d):
-                guest_path_ok = True
-                break
-        if not guest_path_ok:
-            arg_fail(
-                f"error: cannot initialize {guestpath} inside the guest "
-                + "(path must be defined inside a valid overlay)"
-            )
+        # Overlay paths must be defined inside one of the rws, but not vice-versa?
 
         idx = mount_index
         mount_index += 1
diff --git a/virtme/guest/virtme-snapd-script b/virtme/guest/virtme-snapd-script
index 4cbd279..1464780 100755
--- a/virtme/guest/virtme-snapd-script
+++ b/virtme/guest/virtme-snapd-script
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 #
 # Initialize a snap cgroup to emulate a systemd environment, tricking snapd
 # into recognizing our system as a valid one.
diff --git a/virtme/guest/virtme-sound-script b/virtme/guest/virtme-sound-script
index 11fde4e..ccd3860 100755
--- a/virtme/guest/virtme-sound-script
+++ b/virtme/guest/virtme-sound-script
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 if [ -n "$(command -v pipewire)" ]; then
     # Start audio system services.
diff --git a/virtme/guest/virtme-sshd-script b/virtme/guest/virtme-sshd-script
index aa26bd2..209ba3d 100755
--- a/virtme/guest/virtme-sshd-script
+++ b/virtme/guest/virtme-sshd-script
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 #
 # Initialize ssh server for remote connections (option `--server ssh`)
 
@@ -10,6 +10,10 @@ if [ -z "${virtme_ssh_channel}" ]; then
     echo "ssh: virtme_ssh_channel is not defined" >&2
     exit 1
 fi
+if [ -z "${virtme_ssh_pubkey}" ]; then
+    echo "ssh: virtme_ssh_pubkey is not defined" >&2
+    exit 1
+fi
 
 rm -f /var/run/nologin
 
@@ -45,7 +49,8 @@ cp "${SSH_CACHE}"/etc/ssh/* "${SSH_DIR}"/etc/ssh
 # Generate authorized_keys in the virtme-ng cache directory and add all
 # current user's public keys.
 SSH_AUTH_KEYS="${SSH_DIR}"/etc/ssh/authorized_keys
-cat "${SSH_HOME}"/.ssh/id_*.pub >> "${SSH_AUTH_KEYS}" 2> /dev/null
+# TODO: Supports multiple pubkeys? Seems unneccessary?
+echo "${virtme_ssh_pubkey}" >> "${SSH_AUTH_KEYS}"
 
 # fixup permissions
 chown -R root:root "${SSH_DIR}"/etc/ssh
@@ -80,6 +85,7 @@ for key in "${SSH_DIR}"/etc/ssh/ssh_host_*_key; do
     ARGS+=(-h "${key}")
 done
 
+sshd="$(which sshd)"
 if [[ ${virtme_ssh_channel} == "vsock" ]]; then
     # Make sure vsock (module) is loaded and active, otherwise the '/dev/vsock' device
     # might not be available.
@@ -95,12 +101,12 @@ if [[ ${virtme_ssh_channel} == "vsock" ]]; then
     # 4294967295 == U32_MAX == -1
     declare -r VMADDR_CID_ANY=4294967295
     # TODO Use something like syslog or journal for the logging
-    setsid --fork -- systemd-socket-activate --accept --listen="vsock:${VMADDR_CID_ANY}:22" --inetd -- /usr/sbin/sshd -i "${ARGS[@]}" &> /dev/null < /dev/null
+    setsid --fork -- systemd-socket-activate --accept --listen="vsock:${VMADDR_CID_ANY}:22" --inetd -- "$sshd" -i "${ARGS[@]}" &> /dev/null < /dev/null
 else
     if (("${virtme_empty_passwords:-0}" == 1)); then
         echo "Using TCP-based SSH together with empty passwords is insecure." >&2
         exit 1
     fi
 
-    /usr/sbin/sshd "${ARGS[@]}"
+    "$sshd" "${ARGS[@]}"
 fi
diff --git a/virtme/guest/virtme-udhcpc-script b/virtme/guest/virtme-udhcpc-script
index 5c72b6f..86ff0d9 100755
--- a/virtme/guest/virtme-udhcpc-script
+++ b/virtme/guest/virtme-udhcpc-script
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 # virtme-udhcpc-script: A trivial udhcpc script
 # Copyright Â© 2014 Andy Lutomirski
 # Licensed under the GPLv2, which is available in the virtme distribution
diff --git a/virtme_ng/run.py b/virtme_ng/run.py
index 4761ed4..18f2289 100644
--- a/virtme_ng/run.py
+++ b/virtme_ng/run.py
@@ -1007,6 +1007,10 @@ class KernelSource:
         self.virtme_param["rwdir"] = ""
         for item in args.rwdir:
             self.virtme_param["rwdir"] += f"--rwdir {item} "
+        # Map the current directory as rw as well, e.g. linux repo.
+        # For just this directory, we make it as rwdir, it should be fine :)
+        cwd = os.getcwd()
+        self.virtme_param["rwdir"] += f"--rwdir {cwd}={cwd} "
 
     def _get_virtme_overlay_rwdir(self, args):
         # Set default overlays if rootfs is mounted in read-only mode.
diff --git a/virtme_ng_init/src/main.rs b/virtme_ng_init/src/main.rs
index 95b90ed..9f1eaac 100644
--- a/virtme_ng_init/src/main.rs
+++ b/virtme_ng_init/src/main.rs
@@ -21,7 +21,7 @@ use nix::sys::stat::Mode;
 use nix::sys::utsname::uname;
 use nix::unistd::sethostname;
 use std::env;
-use std::fs::{File, OpenOptions};
+use std::fs::{create_dir_all, File, OpenOptions};
 use std::io::{self, BufRead, BufReader, BufWriter, Write};
 use std::os::fd::{AsRawFd, IntoRawFd};
 use std::os::unix::process::CommandExt;
@@ -66,6 +66,13 @@ const KERNEL_MOUNTS: &[MountInfo] = &[
         flags: 0,
         fsdata: "mode=0755",
     },
+    MountInfo {
+        source: "tmp",
+        target: "/tmp",
+        fs_type: "tmpfs",
+        flags: 0,
+        fsdata: "mode=0755",
+    },
     MountInfo {
         source: "devtmpfs",
         target: "/dev",
@@ -205,8 +212,72 @@ fn poweroff() {
     }
 }
 
-fn configure_environment() {
-    env::set_var("PATH", "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin");
+struct NixOSHost {
+    current_system: PathBuf,
+    wrapper_dir: Option<String>,
+    wrappers_script: Option<String>,
+}
+
+enum Host {
+    Linux,
+    NixOS(NixOSHost),
+}
+
+impl Host {
+    fn post_configure(&self) {
+        if let Self::NixOS(host) = self {
+            // Before we move on, Inherit some configurations from a NixOS host:
+            utils::do_symlink(host.current_system.to_str().unwrap(), "/run/current-system");
+            if let Some(dir) = &host.wrapper_dir {
+                utils::do_mkdir(dir.as_str());
+            }
+            if let Some(exec) = &host.wrappers_script {
+                utils::run_cmd(exec, &[]);
+            }
+        }
+    }
+}
+
+fn configure_environment() -> Host {
+    let nix_includes = include_str!("nix-path");
+
+    let current_system = std::fs::read_link("/run/current-system");
+    if current_system.is_err() {
+        // Fallback to normal Linux:
+        env::set_var(
+            "PATH",
+            format!("{nix_includes}:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin"),
+        );
+        return Host::Linux;
+    }
+
+    // If NixOS, @see /run/current-system/{init,activate}
+    // PATH will get updated when bash profile is sourced, we just need what init really needs here.
+    // TODO: Pass path from host env, instead of hardcoded nix-path file.
+    env::set_var(
+        "PATH",
+        format!("{nix_includes}:/run/wrappers/bin:/run/current-system/sw/bin"),
+    );
+
+    // setup security wrappers, for sudo things to work:
+    let mut wrapper_dir = None;
+    let mut wrappers_script = None;
+    for line in std::fs::read_to_string("/etc/systemd/system/suid-sgid-wrappers.service")
+        .unwrap()
+        .lines()
+    {
+        if let Some(dir) = line.strip_prefix("RequiresMountsFor=") {
+            wrapper_dir = Some(dir.trim_end().to_string());
+        } else if let Some(exec) = line.strip_prefix("ExecStart=") {
+            wrappers_script = Some(exec.trim_end().to_string());
+        }
+    }
+
+    Host::NixOS(NixOSHost {
+        current_system: current_system.unwrap(),
+        wrapper_dir,
+        wrappers_script,
+    })
 }
 
 fn get_kernel_version(show_machine: bool) -> String {
@@ -308,11 +379,27 @@ fn generate_shadow() -> io::Result<()> {
     let empty_passwords = env::var("virtme_empty_passwords").unwrap_or(0.to_string());
     let value = if empty_passwords == "1" { "" } else { "!" };
 
+    let mut has_sshd_user = false;
     for line in reader.lines() {
         if let Some((username, _)) = line?.split_once(':') {
+            if username == "sshd" {
+                has_sshd_user = true;
+            }
             writeln!(writer, "{username}:{value}:::::::")?;
         }
     }
+
+    // For sshd + root, we should create a new user called sshd to make privilege separation works.
+    if !has_sshd_user && env::var("virtme_ssh_user").is_ok_and(|u| u == "root") {
+        std::fs::copy("/etc/passwd", "/run/tmp/passwd")?;
+        let mut passwd = OpenOptions::new()
+            .write(true)
+            .append(true)
+            .open("/run/tmp/passwd")?;
+        writeln!(passwd, "sshd:x:109:65534::/run/sshd:/bin/false")?;
+        writeln!(writer, "sshd:!:::::::")?;
+    }
+
     utils::do_mount(
         "/run/tmp/shadow",
         "/etc/shadow",
@@ -326,7 +413,7 @@ fn generate_shadow() -> io::Result<()> {
 
 fn generate_sudoers() -> io::Result<()> {
     let fname = "/run/tmp/sudoers";
-    let mut content = "Defaults secure_path=\"/usr/sbin:/usr/bin:/sbin:/bin\"\n".to_string();
+    let mut content = String::new();
     content += "root ALL = (ALL) NOPASSWD: ALL\n";
     if let Ok(user) = env::var("virtme_user") {
         content += &format!("{user} ALL = (ALL) NOPASSWD: ALL\n");
@@ -477,7 +564,8 @@ fn mount_virtme_overlays() {
 fn mount_virtme_initmounts() {
     for (key, path) in env::vars() {
         if key.starts_with("virtme_initmount") {
-            utils::do_mkdir(&path);
+            // TODO: Make util::do_mkdir supports recursive.
+            create_dir_all(&path).expect("failed to create dir for initmounts");
             utils::do_mount(
                 &key.replace('_', "."),
                 &path,
@@ -579,9 +667,20 @@ fn find_udevd() -> Option<PathBuf> {
     let path = env::var("PATH").unwrap_or_else(|_| String::new());
     let path_candidates = path.split(':').map(|dir| Path::new(dir).join("udevd"));
 
+    let mut service_candidates = vec![];
+    if let Ok(content) = std::fs::read_to_string("/etc/systemd/system/systemd-udevd.service") {
+        for line in content.lines() {
+            if let Some(exec) = line.strip_prefix("ExecStart=") {
+                service_candidates.push(PathBuf::from(exec.trim_end()));
+                break;
+            }
+        }
+    }
+
     static_candidates
         .into_iter()
         .chain(path_candidates)
+        .chain(service_candidates)
         .find(|path| path.exists())
 }
 
@@ -920,7 +1019,7 @@ fn run_user_gui(tty_fd: libc::c_int) {
     if let Err(err) = utils::create_file(
         xinitrc,
         0o0644,
-        &format!("{pre_exec_cmd}\n/bin/bash {USER_SCRIPT}"),
+        &format!("{pre_exec_cmd}\n/usr/bin/env bash {USER_SCRIPT}"),
     ) {
         log!("failed to generate {}: {}", xinitrc, err);
         return;
@@ -1097,7 +1196,6 @@ fn setup_socat_console() {
 fn run_misc_services() -> thread::JoinHandle<()> {
     thread::spawn(|| {
         symlink_fds();
-        mount_virtme_initmounts();
         fix_packaging_files();
         override_system_files();
         run_sshd();
@@ -1120,14 +1218,18 @@ fn print_logo() {
 
 fn main() {
     // Basic system initialization (order is important here).
-    configure_environment();
+    let host = configure_environment();
     configure_hostname();
     mount_kernel_filesystems();
     mount_cgroupfs();
     configure_limits();
+
+    // The overlays may relies on initmounts, e.g. for --root
+    mount_virtme_initmounts();
     mount_virtme_overlays();
     mount_sys_filesystems();
     mount_kernel_modules();
+    host.post_configure();
     run_systemd_tmpfiles();
 
     // Service running in the background for later
-- 
2.51.2

