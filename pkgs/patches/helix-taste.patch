commit 9b7bfc4693d2f1084df8fb93f0db0fe1f4e16871
Author: Zigit Zo <byte@pen.guru>
Date:   Sun Aug 24 00:34:57 2025 +0800

    hack: 25.07.1

diff --git a/.envrc b/.envrc
index 7ddb34dd..77fcb541 100644
--- a/.envrc
+++ b/.envrc
@@ -4,5 +4,5 @@ watch_file flake.lock
 watch_file rust-toolchain.toml
 
 # try to use flakes, if it fails use normal nix (ie. shell.nix)
-use flake || use nix
+use flake . --accept-flake-config || use nix
 eval "$shellHook"
diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index 5bde08e3..7ff8a38f 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -527,6 +527,12 @@ pub fn range_bounds(&self) -> impl Iterator<Item = helix_stdx::Range> + '_ {
         self.ranges.iter().map(|&range| range.into())
     }
 
+    pub fn is_single_grapheme(&self, text: RopeSlice) -> bool {
+        self.ranges()
+            .get(0)
+            .is_some_and(|r| r.is_single_grapheme(text))
+    }
+
     pub fn primary_index(&self) -> usize {
         self.primary_index
     }
diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index afb3b3a5..78df04eb 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -693,6 +693,10 @@ pub(crate) async fn initialize(&self, enable_snippets: bool) -> Result<lsp::Init
                         dynamic_registration: Some(false),
                         resolve_support: None,
                     }),
+                    document_symbol: Some(lsp::DocumentSymbolClientCapabilities {
+                        hierarchical_document_symbol_support: Some(true),
+                        ..Default::default()
+                    }),
                     ..Default::default()
                 }),
                 window: Some(lsp::WindowClientCapabilities {
diff --git a/helix-lsp/src/lib.rs b/helix-lsp/src/lib.rs
index 567e8a70..ced91122 100644
--- a/helix-lsp/src/lib.rs
+++ b/helix-lsp/src/lib.rs
@@ -126,21 +126,18 @@ pub fn diagnostic_to_lsp_diagnostic(
         }
     }
 
-    /// Converts [`lsp::Position`] to a position in the document.
-    ///
-    /// Returns `None` if position.line is out of bounds or an overflow occurs
-    pub fn lsp_pos_to_pos(
+    pub fn lsp_pos_to_line(
         doc: &Rope,
         pos: lsp::Position,
         offset_encoding: OffsetEncoding,
-    ) -> Option<usize> {
+    ) -> Option<std::ops::Range<usize>> {
         let pos_line = pos.line as usize;
         if pos_line > doc.len_lines() - 1 {
             // If it extends past the end, truncate it to the end. This is because the
             // way the LSP describes the range including the last newline is by
             // specifying a line number after what we would call the last line.
             log::warn!("LSP position {pos:?} out of range assuming EOF");
-            return Some(doc.len_chars());
+            return None;
         }
 
         // We need to be careful here to fully comply ith the LSP spec.
@@ -189,6 +186,22 @@ pub fn lsp_pos_to_pos(
             }
         };
 
+        Some(line)
+    }
+
+    /// Converts [`lsp::Position`] to a position in the document.
+    ///
+    /// Returns `None` if position.line is out of bounds or an overflow occurs
+    pub fn lsp_pos_to_pos(
+        doc: &Rope,
+        pos: lsp::Position,
+        offset_encoding: OffsetEncoding,
+    ) -> Option<usize> {
+        let line = match lsp_pos_to_line(doc, pos, offset_encoding) {
+            Some(line) => line,
+            None => return Some(doc.len_chars()),
+        };
+
         // The LSP spec demands that the offset is capped to the end of the line
         let pos = line
             .start
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 304dcd88..c950a18a 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -61,7 +61,10 @@
     compositor::{self, Component, Compositor},
     filter_picker_entry,
     job::Callback,
-    ui::{self, overlay::overlaid, Picker, PickerColumn, Popup, Prompt, PromptEvent},
+    ui::{
+        self, overlay::overlaid, transform_search_query, Picker, PickerColumn, Popup, Prompt,
+        PromptEvent,
+    },
 };
 
 use crate::job::{self, Jobs};
@@ -557,6 +560,8 @@ pub fn doc(&self) -> &str {
         select_textobject_inner, "Select inside object",
         goto_next_function, "Goto next function",
         goto_prev_function, "Goto previous function",
+        goto_next_function_name, "Goto next function name",
+        goto_prev_function_name, "Goto previous function name",
         goto_next_class, "Goto next type definition",
         goto_prev_class, "Goto previous type definition",
         goto_next_parameter, "Goto next parameter",
@@ -603,6 +608,8 @@ pub fn doc(&self) -> &str {
         goto_prev_tabstop, "Goto next snippet placeholder",
         rotate_selections_first, "Make the first selection your primary one",
         rotate_selections_last, "Make the last selection your primary one",
+        goto_word_definition, "Definition of a two-character label",
+        goto_word_reference, "Reference of a two-character label",
     );
 }
 
@@ -2282,11 +2289,8 @@ fn search_next_or_prev_impl(cx: &mut Context, movement: Movement, direction: Dir
     let scrolloff = config.scrolloff;
     if let Some(query) = cx.editor.registers.first(register, cx.editor) {
         let search_config = &config.search;
-        let case_insensitive = if search_config.smart_case {
-            !query.chars().any(char::is_uppercase)
-        } else {
-            false
-        };
+        let (query, case_insensitive) = transform_search_query(search_config, query.as_ref());
+
         let wrap_around = search_config.wrap_around;
         if let Ok(regex) = rope::RegexBuilder::new()
             .syntax(
@@ -2338,6 +2342,10 @@ fn search_selection_detect_word_boundaries(cx: &mut Context) {
 }
 
 fn search_selection_impl(cx: &mut Context, detect_word_boundaries: bool) {
+    if cx.count.is_none() {
+        do_expand_selection(cx.editor, true);
+    }
+
     fn is_at_word_start(text: RopeSlice, index: usize) -> bool {
         // This can happen when the cursor is at the last character in
         // the document +1 (ge + j), in this case text.char(index) will panic as
@@ -2456,16 +2464,17 @@ fn new(path: &Path, line_num: usize) -> Self {
     }
 
     struct GlobalSearchConfig {
-        smart_case: bool,
+        search_config: helix_view::editor::SearchConfig,
         file_picker_config: helix_view::editor::FilePickerConfig,
         directory_style: Style,
         number_style: Style,
         colon_style: Style,
     }
 
+    // TODO: try to avoid copy with Rc or else?
     let config = cx.editor.config();
     let config = GlobalSearchConfig {
-        smart_case: config.search.smart_case,
+        search_config: config.search.clone(),
         file_picker_config: config.file_picker.clone(),
         directory_style: cx.editor.theme.get("ui.text.directory"),
         number_style: cx.editor.theme.get("constant.numeric.integer"),
@@ -2517,9 +2526,11 @@ struct GlobalSearchConfig {
             .map(|doc| (doc.path().cloned(), doc.text().to_owned()))
             .collect();
 
+        // TODO: better smart-case?
+        let (query, case_insensitive) = transform_search_query(&config.search_config, query);
         let matcher = match RegexMatcherBuilder::new()
-            .case_smart(config.smart_case)
-            .build(query)
+            .case_insensitive(case_insensitive)
+            .build(query.as_ref())
         {
             Ok(matcher) => {
                 // Clear any "Failed to compile regex" errors out of the statusline.
@@ -2662,7 +2673,7 @@ struct GlobalSearchConfig {
     .with_preview(|_editor, FileResult { path, line_num, .. }| {
         Some((path.as_path().into(), Some((*line_num, *line_num))))
     })
-    .with_history_register(Some(reg))
+    .with_history_register(Some(reg), cx.editor)
     .with_dynamic_query(get_files, Some(275));
 
     cx.push_layer(Box::new(overlaid(picker)));
@@ -3057,11 +3068,7 @@ fn file_picker(cx: &mut Context) {
 }
 
 fn file_picker_in_current_buffer_directory(cx: &mut Context) {
-    let doc_dir = doc!(cx.editor)
-        .path()
-        .and_then(|path| path.parent().map(|path| path.to_path_buf()));
-
-    let path = match doc_dir {
+    let path = match cx.editor.current_buffer_directory() {
         Some(path) => path,
         None => {
             cx.editor.set_error("current buffer has no path or parent");
@@ -5366,14 +5373,18 @@ fn reverse_selection_contents(cx: &mut Context) {
 
 // tree sitter node selection
 
-fn expand_selection(cx: &mut Context) {
-    let motion = |editor: &mut Editor| {
+fn do_expand_selection(editor: &mut Editor, skip_if_selected: bool) {
+    if true {
         let (view, doc) = current!(editor);
 
         if let Some(syntax) = doc.syntax() {
             let text = doc.text().slice(..);
 
             let current_selection = doc.selection(view.id);
+            if skip_if_selected && !current_selection.is_single_grapheme(text) {
+                return;
+            }
+
             let selection = object::expand_selection(syntax, text, current_selection.clone());
 
             // check if selection is different from the last one
@@ -5385,7 +5396,11 @@ fn expand_selection(cx: &mut Context) {
             }
         }
     };
-    cx.editor.apply_motion(motion);
+}
+
+fn expand_selection(cx: &mut Context) {
+    cx.editor
+        .apply_motion(|editor: &mut Editor| do_expand_selection(editor, false));
 }
 
 fn shrink_selection(cx: &mut Context) {
@@ -5850,6 +5865,14 @@ fn goto_prev_function(cx: &mut Context) {
     goto_ts_object_impl(cx, "function", Direction::Backward)
 }
 
+fn goto_next_function_name(cx: &mut Context) {
+    goto_ts_object_impl(cx, "function_name", Direction::Forward)
+}
+
+fn goto_prev_function_name(cx: &mut Context) {
+    goto_ts_object_impl(cx, "function_name", Direction::Backward)
+}
+
 fn goto_next_class(cx: &mut Context) {
     goto_ts_object_impl(cx, "class", Direction::Forward)
 }
@@ -6630,14 +6653,27 @@ fn replay_macro(cx: &mut Context) {
 }
 
 fn goto_word(cx: &mut Context) {
-    jump_to_word(cx, Movement::Move)
+    jump_to_word(cx, Movement::Move, None)
 }
 
 fn extend_to_word(cx: &mut Context) {
-    jump_to_word(cx, Movement::Extend)
+    jump_to_word(cx, Movement::Extend, None)
 }
 
-fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
+fn goto_word_reference(cx: &mut Context) {
+    jump_to_word(cx, Movement::Move, Some(goto_reference))
+}
+
+fn goto_word_definition(cx: &mut Context) {
+    jump_to_word(cx, Movement::Move, Some(goto_definition))
+}
+
+fn jump_to_label(
+    cx: &mut Context,
+    labels: Vec<Range>,
+    behaviour: Movement,
+    do_next: Option<fn(&mut Context)>,
+) {
     let doc = doc!(cx.editor);
     let alphabet = &cx.editor.config().jump_label_alphabet;
     if labels.is_empty() {
@@ -6718,15 +6754,23 @@ fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
                     };
                     Range::new(anchor, range.head)
                 } else {
+                    // Movement, save to jumplist before we jump
+                    let (view, doc) = current!(cx.editor);
+                    push_jump(view, doc);
+
                     range.with_direction(Direction::Forward)
                 };
                 doc_mut!(cx.editor, &doc).set_selection(view, range.into());
+
+                if let Some(func) = do_next {
+                    func(cx);
+                }
             }
         });
     });
 }
 
-fn jump_to_word(cx: &mut Context, behaviour: Movement) {
+fn jump_to_word(cx: &mut Context, behaviour: Movement, do_next: Option<fn(&mut Context)>) {
     // Calculate the jump candidates: ranges for any visible words with two or
     // more characters.
     let alphabet = &cx.editor.config().jump_label_alphabet;
@@ -6821,5 +6865,5 @@ fn jump_to_word(cx: &mut Context, behaviour: Movement) {
             break;
         }
     }
-    jump_to_label(cx, words, behaviour)
+    jump_to_label(cx, words, behaviour, do_next)
 }
diff --git a/helix-term/src/commands/lsp.rs b/helix-term/src/commands/lsp.rs
index ac9dd6e2..f3c44fbc 100644
--- a/helix-term/src/commands/lsp.rs
+++ b/helix-term/src/commands/lsp.rs
@@ -5,7 +5,7 @@
         self, CodeAction, CodeActionOrCommand, CodeActionTriggerKind, DiagnosticSeverity,
         NumberOrString,
     },
-    util::{diagnostic_to_lsp_diagnostic, lsp_range_to_range, range_to_lsp_range},
+    util::{diagnostic_to_lsp_diagnostic, lsp_pos_to_line, lsp_range_to_range, range_to_lsp_range},
     Client, LanguageServerId, OffsetEncoding,
 };
 use tokio_stream::StreamExt;
@@ -29,10 +29,19 @@
 use crate::{
     compositor::{self, Compositor},
     job::Callback,
-    ui::{self, overlay::overlaid, FileLocation, Picker, Popup, PromptEvent},
+    ui::{
+        self, overlay::overlaid, picker::DocumentPreviewCache, FileLocation, Picker, Popup,
+        PromptEvent,
+    },
 };
 
-use std::{cmp::Ordering, collections::HashSet, fmt::Display, future::Future, path::Path};
+use std::{
+    cmp::Ordering,
+    collections::{HashMap, HashSet},
+    fmt::Display,
+    future::Future,
+    path::Path,
+};
 
 /// Gets the first language server that is attached to a document which supports a specific feature.
 /// If there is no configured language server that supports the feature, this displays a status message.
@@ -63,6 +72,7 @@ struct Location {
     uri: Uri,
     range: lsp::Range,
     offset_encoding: OffsetEncoding,
+    kind: Option<lsp::DocumentHighlightKind>,
 }
 
 fn lsp_location_to_location(
@@ -80,12 +90,14 @@ fn lsp_location_to_location(
         uri,
         range: location.range,
         offset_encoding,
+        kind: None,
     })
 }
 
 struct SymbolInformationItem {
     location: Location,
     symbol: lsp::SymbolInformation,
+    signature: Option<String>,
 }
 
 struct DiagnosticStyles {
@@ -224,6 +236,7 @@ fn diag_picker(
                         uri: uri.clone(),
                         range: diag.range,
                         offset_encoding: ls.offset_encoding(),
+                        kind: None,
                     },
                     diag,
                 });
@@ -309,26 +322,36 @@ fn nested_to_flat(
         uri: &Uri,
         symbol: lsp::DocumentSymbol,
         offset_encoding: OffsetEncoding,
+        container_name: &mut String,
     ) {
         #[allow(deprecated)]
         list.push(SymbolInformationItem {
             symbol: lsp::SymbolInformation {
-                name: symbol.name,
+                name: symbol.name.clone(),
                 kind: symbol.kind,
                 tags: symbol.tags,
                 deprecated: symbol.deprecated,
                 location: lsp::Location::new(file.uri.clone(), symbol.selection_range),
-                container_name: None,
+                container_name: Some(container_name.clone()),
             },
             location: Location {
                 uri: uri.clone(),
                 range: symbol.selection_range,
                 offset_encoding,
+                kind: None,
             },
+            signature: symbol.detail,
         });
+
+        let old_len = container_name.len();
+        if old_len != 0 {
+            container_name.push_str("::"); // cpp style
+        }
+        container_name.push_str(symbol.name.as_str());
         for child in symbol.children.into_iter().flatten() {
-            nested_to_flat(list, file, uri, child, offset_encoding);
+            nested_to_flat(list, file, uri, child, offset_encoding, container_name);
         }
+        container_name.truncate(old_len);
     }
     let doc = doc!(cx.editor);
 
@@ -360,10 +383,13 @@ fn nested_to_flat(
                                 uri: doc_uri.clone(),
                                 range: symbol.location.range,
                                 offset_encoding,
+                                kind: None,
                             },
                             symbol,
+                            signature: None,
                         })
                         .collect(),
+                    // for rust-analyzer: `snap.config.hierarchical_symbols` must be enabled
                     lsp::DocumentSymbolResponse::Nested(symbols) => {
                         let mut flat_symbols = Vec::new();
                         for symbol in symbols {
@@ -373,6 +399,7 @@ fn nested_to_flat(
                                 &doc_uri,
                                 symbol,
                                 offset_encoding,
+                                &mut String::new(),
                             )
                         }
                         flat_symbols
@@ -415,6 +442,14 @@ fn nested_to_flat(
                         .unwrap_or_default()
                         .into()
                 }),
+                // Signature of the symbol
+                ui::PickerColumn::new("signature", |item: &SymbolInformationItem, _| {
+                    if let Some(ref signature) = item.signature {
+                        signature.to_string().into()
+                    } else {
+                        "".into()
+                    }
+                }),
             ];
 
             let picker = Picker::new(
@@ -485,8 +520,10 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
                                     uri,
                                     range: symbol.location.range,
                                     offset_encoding,
+                                    kind: None,
                                 },
                                 symbol,
+                                signature: None,
                             })
                         })
                         .collect();
@@ -846,7 +883,12 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 }
 
 /// Precondition: `locations` should be non-empty.
-fn goto_impl(editor: &mut Editor, compositor: &mut Compositor, locations: Vec<Location>) {
+fn goto_impl(
+    editor: &mut Editor,
+    compositor: &mut Compositor,
+    locations: Vec<Location>,
+    show_kind: bool,
+) {
     let cwdir = helix_stdx::env::current_working_dir();
 
     match locations.as_slice() {
@@ -855,9 +897,45 @@ fn goto_impl(editor: &mut Editor, compositor: &mut Compositor, locations: Vec<Lo
         }
         [] => unreachable!("`locations` should be non-empty for `goto_impl`"),
         _locations => {
-            let columns = [ui::PickerColumn::new(
-                "location",
-                |item: &Location, cwdir: &std::path::PathBuf| {
+            // Manage the preview cache ourselves to speed up a little:
+            let mut preview_cache = DocumentPreviewCache::new();
+
+            // [Location] -> [(Location, Line?)]
+            let mut symbol_name: Option<String> = None;
+            let locations = locations
+                .into_iter()
+                .map(|loc| {
+                    let line = loc.uri.as_path().and_then(|path| {
+                        let preview = preview_cache.get_preview(path, editor);
+                        let doc = preview.document()?;
+
+                        // Extract symbol name from better displaying, any of it is fine:
+                        if symbol_name.is_none() {
+                            let range =
+                                lsp_range_to_range(doc.text(), loc.range, loc.offset_encoding)?;
+                            symbol_name =
+                                Some(doc.text().get_slice(range.anchor..range.head)?.to_string());
+                        }
+
+                        // Extract all the relative lines, we do it here to avoid Sync:
+                        let range =
+                            lsp_pos_to_line(doc.text(), loc.range.start, loc.offset_encoding)?;
+                        Some(
+                            doc.text()
+                                .get_slice(range)?
+                                .chars()
+                                .skip_while(|&ch| char::is_whitespace(ch))
+                                .collect(),
+                        )
+                    });
+                    (loc, line)
+                })
+                .collect::<Vec<_>>();
+
+            let mut columns = Vec::with_capacity(3);
+            columns.push(ui::PickerColumn::new(
+                "path",
+                |(item, _): &(Location, Option<String>), cwdir: &std::path::PathBuf| {
                     let path = if let Some(path) = item.uri.as_path() {
                         path.strip_prefix(cwdir).unwrap_or(path).to_string_lossy()
                     } else {
@@ -866,12 +944,39 @@ fn goto_impl(editor: &mut Editor, compositor: &mut Compositor, locations: Vec<Lo
 
                     format!("{path}:{}", item.range.start.line + 1).into()
                 },
-            )];
+            ));
+            if show_kind {
+                columns.push(ui::PickerColumn::new(
+                    "kind",
+                    |(item, _): &(Location, Option<String>), _: &std::path::PathBuf| {
+                        match item.kind {
+                            None => "",
+                            Some(k) if k == lsp::DocumentHighlightKind::TEXT => "text",
+                            Some(k) if k == lsp::DocumentHighlightKind::READ => "read",
+                            Some(k) if k == lsp::DocumentHighlightKind::WRITE => "write",
+                            Some(_) => "unknown",
+                        }
+                        .into()
+                    },
+                ))
+            }
+            columns.push(ui::PickerColumn::new(
+                "line",
+                |(_, line): &(Location, Option<String>), _: &std::path::PathBuf| {
+                    line.clone().unwrap_or_default().into()
+                },
+            ));
 
-            let picker = Picker::new(columns, 0, locations, cwdir, |cx, location, action| {
-                jump_to_location(cx.editor, location, action)
-            })
-            .with_preview(|_editor, location| location_to_file_location(location));
+            let picker = Picker::new(
+                columns,
+                0,
+                locations,
+                cwdir,
+                move |cx, (location, _), action| jump_to_location(cx.editor, location, action),
+            )
+            .with_prefix(symbol_name.unwrap_or_default())
+            .with_cached_previews(preview_cache)
+            .with_preview(move |_editor, (location, _)| location_to_file_location(location));
             compositor.push(Box::new(overlaid(picker)));
         }
     }
@@ -930,7 +1035,7 @@ fn goto_single_impl<P, F>(cx: &mut Context, feature: LanguageServerFeature, requ
             if locations.is_empty() {
                 editor.set_error("No definition found.");
             } else {
-                goto_impl(editor, compositor, locations);
+                goto_impl(editor, compositor, locations, false);
             }
         };
         Ok(Callback::EditorCompositor(Box::new(call)))
@@ -990,6 +1095,10 @@ pub fn goto_reference(cx: &mut Context) {
         })
         .collect();
 
+    let hl_language_server = doc
+        .arc_language_servers_with_feature(LanguageServerFeature::DocumentHighlight)
+        .next();
+
     cx.jobs.callback(async move {
         let mut locations = Vec::new();
         while let Some(response) = futures.next().await {
@@ -1003,11 +1112,47 @@ pub fn goto_reference(cx: &mut Context) {
                 Err(err) => log::error!("Error requesting references: {err}"),
             }
         }
+
+        // For marking read/write:
+        if let Some(hl_language_server) = hl_language_server {
+            let mut highlights =
+                HashMap::<(url::Url, lsp::Position), Option<lsp::DocumentHighlightKind>>::new();
+
+            for loc in &mut locations {
+                let highlight = (loc.uri.to_url().unwrap(), loc.range.start);
+                loc.kind = if let Some(r) = highlights.get(&highlight) {
+                    *r
+                } else {
+                    let result = hl_language_server
+                        .text_document_document_highlight(
+                            lsp::TextDocumentIdentifier::new(highlight.0.clone()),
+                            loc.range.start,
+                            None,
+                        )
+                        .unwrap()
+                        .await;
+                    // LSP requries a `DidOpen` for DocumentHighlight, but opening all files in
+                    // reference is way too slow, and we're now ignoring the errors here...
+                    let mut last = None;
+                    if let Ok(result) = result {
+                        for hl in result.unwrap_or_default() {
+                            highlights.insert((highlight.0.clone(), hl.range.start), hl.kind);
+                            // To avoid extra map lookup here, TODO: performance!
+                            if last.is_none() && loc.range.start == hl.range.start {
+                                last = hl.kind
+                            }
+                        }
+                    }
+                    last
+                };
+            }
+        }
+
         let call = move |editor: &mut Editor, compositor: &mut Compositor| {
             if locations.is_empty() {
                 editor.set_error("No references found.");
             } else {
-                goto_impl(editor, compositor, locations);
+                goto_impl(editor, compositor, locations, true);
             }
         };
         Ok(Callback::EditorCompositor(Box::new(call)))
diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index 82cad838..a42f2edc 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -133,6 +133,32 @@ fn open(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> anyhow:
     Ok(())
 }
 
+fn open_in_current(
+    cx: &mut compositor::Context,
+    args: Args,
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    ensure!(!args.is_empty(), "wrong argument count");
+
+    let doc_dir = match cx.editor.current_buffer_directory() {
+        Some(p) => p,
+        None => bail!("current buffer has no path or parent"),
+    };
+    let doc_dir = doc_dir.to_string_lossy();
+
+    // Transform all arguments, performance may be poor, but doesn't matter:
+    let mut mapped = Args::default();
+    for arg in args {
+        mapped.push(Cow::from(format!("{doc_dir}/{arg}")))?
+    }
+
+    open(cx, mapped, event)
+}
+
 fn buffer_close_by_ids_impl(
     cx: &mut compositor::Context,
     doc_ids: &[DocumentId],
@@ -357,21 +383,24 @@ fn write_impl(
     doc.append_changes_to_history(view);
 
     let (view, doc) = current_ref!(cx.editor);
-    let fmt = if config.auto_format && options.auto_format {
-        doc.auto_format(cx.editor).map(|fmt| {
-            let callback = make_format_callback(
-                doc.id(),
-                doc.version(),
-                view.id,
-                fmt,
-                Some((path.map(Into::into), options.force)),
-            );
-
-            jobs.add(Job::with_callback(callback).wait_before_exiting());
-        })
+    let fmt = if options.must_format {
+        doc.format(cx.editor)
+    } else if config.auto_format && options.auto_format {
+        doc.auto_format(cx.editor)
     } else {
         None
     };
+    let fmt = fmt.map(|fmt| {
+        let callback = make_format_callback(
+            doc.id(),
+            doc.version(),
+            view.id,
+            fmt,
+            Some((path.map(Into::into), options.force)),
+        );
+
+        jobs.add(Job::with_callback(callback).wait_before_exiting());
+    });
 
     if fmt.is_none() {
         let id = doc.id();
@@ -444,6 +473,7 @@ fn insert_final_newline(doc: &mut Document, view_id: ViewId) {
 pub struct WriteOptions {
     pub force: bool,
     pub auto_format: bool,
+    pub must_format: bool,
 }
 
 fn write(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> anyhow::Result<()> {
@@ -457,6 +487,7 @@ fn write(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> anyhow
         WriteOptions {
             force: false,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )
 }
@@ -472,6 +503,7 @@ fn force_write(cx: &mut compositor::Context, args: Args, event: PromptEvent) ->
         WriteOptions {
             force: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )
 }
@@ -491,6 +523,7 @@ fn write_buffer_close(
         WriteOptions {
             force: false,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )?;
 
@@ -513,6 +546,7 @@ fn force_write_buffer_close(
         WriteOptions {
             force: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )?;
 
@@ -701,6 +735,7 @@ fn write_quit(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> a
         WriteOptions {
             force: false,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )?;
     cx.block_try_flush_writes()?;
@@ -722,6 +757,7 @@ fn force_write_quit(
         WriteOptions {
             force: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )?;
     cx.block_try_flush_writes()?;
@@ -766,6 +802,7 @@ pub struct WriteAllOptions {
     pub force: bool,
     pub write_scratch: bool,
     pub auto_format: bool,
+    pub must_format: bool,
 }
 
 pub fn write_all_impl(
@@ -817,21 +854,24 @@ pub fn write_all_impl(
         // Save an undo checkpoint for any outstanding changes.
         doc.append_changes_to_history(view);
 
-        let fmt = if options.auto_format && config.auto_format {
-            let doc = doc!(cx.editor, &doc_id);
-            doc.auto_format(cx.editor).map(|fmt| {
-                let callback = make_format_callback(
-                    doc_id,
-                    doc.version(),
-                    target_view,
-                    fmt,
-                    Some((None, options.force)),
-                );
-                jobs.add(Job::with_callback(callback).wait_before_exiting());
-            })
+        let doc = doc!(cx.editor, &doc_id);
+        let fmt = if options.must_format {
+            doc.format(cx.editor)
+        } else if options.auto_format && config.auto_format {
+            doc.auto_format(cx.editor)
         } else {
             None
         };
+        let fmt = fmt.map(|fmt| {
+            let callback = make_format_callback(
+                doc_id,
+                doc.version(),
+                target_view,
+                fmt,
+                Some((None, options.force)),
+            );
+            jobs.add(Job::with_callback(callback).wait_before_exiting());
+        });
 
         if fmt.is_none() {
             cx.editor.save::<PathBuf>(doc_id, None, options.force)?;
@@ -856,6 +896,7 @@ fn write_all(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> an
             force: false,
             write_scratch: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )
 }
@@ -875,6 +916,7 @@ fn force_write_all(
             force: true,
             write_scratch: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )
 }
@@ -893,6 +935,7 @@ fn write_all_quit(
             force: false,
             write_scratch: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     )?;
     quit_all_impl(cx, false)
@@ -912,6 +955,7 @@ fn force_write_all_quit(
             force: true,
             write_scratch: true,
             auto_format: !args.has_flag(WRITE_NO_FORMAT_FLAG.name),
+            must_format: args.has_flag(WRITE_MUST_FORMAT_FLAG.name),
         },
     );
     quit_all_impl(cx, true)
@@ -2671,6 +2715,12 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
     ..Flag::DEFAULT
 };
 
+const WRITE_MUST_FORMAT_FLAG: Flag = Flag {
+    name: "format",
+    doc: "the doc must be formatted, will ignore --no-format",
+    ..Flag::DEFAULT
+};
+
 pub const TYPABLE_COMMAND_LIST: &[TypableCommand] = &[
     TypableCommand {
         name: "quit",
@@ -2705,6 +2755,17 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
             ..Signature::DEFAULT
         },
     },
+    TypableCommand {
+        name: "open-in-current",
+        aliases: &["O", "E"],
+        doc: "Open a file based on current buffer's directory.",
+        fun: open_in_current,
+        completer: CommandCompleter::all(completers::filename_in_current),
+        signature: Signature {
+            positionals: (1, None),
+            ..Signature::DEFAULT
+        }
+    },
     TypableCommand {
         name: "buffer-close",
         aliases: &["bc", "bclose"],
@@ -2795,7 +2856,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2807,7 +2868,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2819,7 +2880,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2831,7 +2892,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2912,7 +2973,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2924,7 +2985,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::positional(&[completers::filename]),
         signature: Signature {
             positionals: (0, Some(1)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2936,7 +2997,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::none(),
         signature: Signature {
             positionals: (0, Some(0)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2948,7 +3009,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::none(),
         signature: Signature {
             positionals: (0, Some(0)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2960,7 +3021,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::none(),
         signature: Signature {
             positionals: (0, Some(0)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
@@ -2972,7 +3033,7 @@ fn noop(_cx: &mut compositor::Context, _args: Args, _event: PromptEvent) -> anyh
         completer: CommandCompleter::none(),
         signature: Signature {
             positionals: (0, Some(0)),
-            flags: &[WRITE_NO_FORMAT_FLAG],
+            flags: &[WRITE_NO_FORMAT_FLAG, WRITE_MUST_FORMAT_FLAG],
             ..Signature::DEFAULT
         },
     },
diff --git a/helix-term/src/handlers/auto_save.rs b/helix-term/src/handlers/auto_save.rs
index 47e2ecfd..38e9b851 100644
--- a/helix-term/src/handlers/auto_save.rs
+++ b/helix-term/src/handlers/auto_save.rs
@@ -91,6 +91,7 @@ fn request_auto_save(editor: &mut Editor) {
         force: false,
         write_scratch: false,
         auto_format: false,
+        must_format: false,
     };
 
     if let Err(e) = commands::typed::write_all_impl(context, options) {
diff --git a/helix-term/src/keymap.rs b/helix-term/src/keymap.rs
index d8227b50..7c0713e1 100644
--- a/helix-term/src/keymap.rs
+++ b/helix-term/src/keymap.rs
@@ -72,18 +72,31 @@ pub fn merge(&mut self, mut other: Self) {
         }
     }
 
-    pub fn infobox(&self) -> Info {
-        let mut body: Vec<(BTreeSet<KeyEvent>, &str)> = Vec::with_capacity(self.len());
+    pub fn infobox(&self, editor: &helix_view::Editor) -> Info {
+        let mut body: Vec<(BTreeSet<KeyEvent>, String)> = Vec::with_capacity(self.len());
         for (&key, trie) in self.iter() {
             let desc = match trie {
                 KeyTrie::MappableCommand(cmd) => {
                     if cmd.name() == "no_op" {
                         continue;
                     }
-                    cmd.doc()
+
+                    // Special handling for ":toggle_option", we show the current value as well.
+                    // TODO: more generic approach, to make other mappable/typable commands work.
+                    match cmd {
+                        MappableCommand::Typable { name, args, .. } if name == "toggle-option" => {
+                            let pointer = format!("/{}", args.replace('.', "/"));
+                            let value = serde_json::json!(editor.config().deref())
+                                .pointer(&pointer)
+                                .unwrap()
+                                .clone();
+                            format!("{} ?{}", cmd.doc(), value)
+                        }
+                        _ => cmd.doc().to_string(),
+                    }
                 }
-                KeyTrie::Node(n) => &n.name,
-                KeyTrie::Sequence(_) => "[Multiple commands]",
+                KeyTrie::Node(n) => n.name.to_string(),
+                KeyTrie::Sequence(_) => "[Multiple commands]".to_string(),
             };
             match body.iter().position(|(_, d)| d == &desc) {
                 Some(pos) => {
diff --git a/helix-term/src/keymap/default.rs b/helix-term/src/keymap/default.rs
index 82baf336..04b9190f 100644
--- a/helix-term/src/keymap/default.rs
+++ b/helix-term/src/keymap/default.rs
@@ -17,7 +17,8 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "F" => find_prev_char,
         "r" => replace,
         "R" => replace_with_yanked,
-        "A-." =>  repeat_last_motion,
+        // "." => repeat_last_insert is defined in @see command_mode
+        "A-." => repeat_last_motion,
 
         "~" => switch_case,
         "`" => switch_to_lowercase,
@@ -78,7 +79,6 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "C" => copy_selection_on_next_line,
         "A-C" => copy_selection_on_prev_line,
 
-
         "s" => select_regex,
         "A-s" => split_selection_on_newline,
         "A-minus" => merge_selections,
@@ -114,6 +114,7 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
             "g" => goto_prev_change,
             "G" => goto_first_change,
             "f" => goto_prev_function,
+            "n" => goto_prev_function_name,
             "t" => goto_prev_class,
             "a" => goto_prev_parameter,
             "c" => goto_prev_comment,
@@ -128,6 +129,7 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
             "g" => goto_next_change,
             "G" => goto_last_change,
             "f" => goto_next_function,
+            "n" => goto_next_function_name,
             "t" => goto_next_class,
             "a" => goto_next_parameter,
             "c" => goto_next_comment,
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 9343d55d..ef0fc1e8 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -838,7 +838,7 @@ fn handle_keymap_event(
         let mut last_mode = mode;
         self.pseudo_pending.extend(self.keymaps.pending());
         let key_result = self.keymaps.get(mode, event);
-        cxt.editor.autoinfo = self.keymaps.sticky().map(|node| node.infobox());
+        cxt.editor.autoinfo = self.keymaps.sticky().map(|node| node.infobox(&cxt.editor));
 
         let mut execute_command = |command: &commands::MappableCommand| {
             command.execute(cxt);
@@ -869,7 +869,7 @@ fn handle_keymap_event(
             KeymapResult::Matched(command) => {
                 execute_command(command);
             }
-            KeymapResult::Pending(node) => cxt.editor.autoinfo = Some(node.infobox()),
+            KeymapResult::Pending(node) => cxt.editor.autoinfo = Some(node.infobox(&cxt.editor)),
             KeymapResult::MatchedSequence(commands) => {
                 for command in commands {
                     execute_command(command);
@@ -1477,6 +1477,7 @@ fn handle_event(
                         force: false,
                         write_scratch: false,
                         auto_format: false,
+                        must_format: false,
                     };
                     if let Err(e) = commands::typed::write_all_impl(context, options) {
                         context.editor.set_error(format!("{}", e));
@@ -1539,10 +1540,11 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
                 cx.editor.theme.get("ui.text")
             };
 
-            surface.set_string(
+            surface.set_stringn(
                 area.x,
                 area.y + area.height.saturating_sub(1),
                 status_msg,
+                area.width as usize,
                 style,
             );
         }
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index 004c8836..5175e492 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -19,7 +19,9 @@
 use crate::job::{self, Callback};
 pub use completion::Completion;
 pub use editor::EditorView;
+use helix_core::regex;
 use helix_stdx::rope;
+use helix_view::editor::SearchConfig;
 use helix_view::theme::Style;
 pub use markdown::Markdown;
 pub use menu::Menu;
@@ -72,6 +74,32 @@ pub fn prompt_with_input(
     cx.push_layer(Box::new(prompt));
 }
 
+pub fn transform_search_query(config: &SearchConfig, query: &str) -> (String, bool) {
+    let case_insensitive = if config.case_sensitive {
+        false
+    } else if config.smart_case {
+        !query.chars().any(char::is_uppercase)
+    } else {
+        false
+    };
+
+    let input = if !config.regex {
+        regex::escape(query)
+    } else {
+        // TODO: avoid copy
+        query.to_string()
+    };
+
+    return (
+        if config.whole_word {
+            format!(r"\b{}\b", input)
+        } else {
+            input
+        },
+        case_insensitive,
+    );
+}
+
 pub fn regex_prompt(
     cx: &mut crate::commands::Context,
     prompt: std::borrow::Cow<'static, str>,
@@ -87,6 +115,7 @@ pub fn regex_prompt(
         move |cx, regex, _, event| fun(cx, regex, event),
     );
 }
+
 pub fn raw_regex_prompt(
     cx: &mut crate::commands::Context,
     prompt: std::borrow::Cow<'static, str>,
@@ -117,19 +146,14 @@ pub fn raw_regex_prompt(
                         return;
                     }
 
-                    let case_insensitive = if config.search.smart_case {
-                        !input.chars().any(char::is_uppercase)
-                    } else {
-                        false
-                    };
-
+                    let (input, case_insensitive) = transform_search_query(&config.search, input);
                     match rope::RegexBuilder::new()
                         .syntax(
                             rope::Config::new()
                                 .case_insensitive(case_insensitive)
                                 .multi_line(true),
                         )
-                        .build(input)
+                        .build(input.as_str())
                     {
                         Ok(regex) => {
                             let (view, doc) = current!(cx.editor);
@@ -142,7 +166,7 @@ pub fn raw_regex_prompt(
                                 view.jumps.push((doc_id, snapshot.clone()));
                             }
 
-                            fun(cx, regex, input, event);
+                            fun(cx, regex, input.as_str(), event);
 
                             let (view, doc) = current!(cx.editor);
                             view.ensure_cursor_in_view(doc, config.scrolloff);
@@ -476,6 +500,27 @@ pub fn filename(editor: &Editor, input: &str) -> Vec<Completion> {
         filename_with_git_ignore(editor, input, true)
     }
 
+    pub fn filename_in_current(editor: &Editor, input: &str) -> Vec<Completion> {
+        // @see open_in_current
+        let doc_path = match editor.current_buffer_directory() {
+            Some(p) => p,
+            None => return Vec::new(),
+        };
+
+        let doc_path = doc_path.to_string_lossy();
+        let input = format!("{doc_path}/{input}");
+
+        // Should complete at the "really" input end (the user typed):
+        // @see change_completion_selection
+        filename_with_git_ignore(editor, input.as_str(), true)
+            .iter()
+            .map(|p| {
+                let start = p.0.start - doc_path.len() - 1;
+                (start.., p.1.clone())
+            })
+            .collect()
+    }
+
     pub fn filename_with_git_ignore(
         editor: &Editor,
         input: &str,
diff --git a/helix-term/src/ui/picker.rs b/helix-term/src/ui/picker.rs
index 3f3aaba2..4f12ccd8 100644
--- a/helix-term/src/ui/picker.rs
+++ b/helix-term/src/ui/picker.rs
@@ -56,7 +56,7 @@
 
 pub const ID: &str = "picker";
 
-pub const MIN_AREA_WIDTH_FOR_PREVIEW: u16 = 72;
+pub const MIN_AREA_WIDTH_FOR_PREVIEW: u16 = 144;
 /// Biggest file size to preview in bytes
 pub const MAX_FILE_SIZE_FOR_PREVIEW: u64 = 10 * 1024 * 1024;
 
@@ -99,7 +99,7 @@ pub enum Preview<'picker, 'editor> {
 }
 
 impl Preview<'_, '_> {
-    fn document(&self) -> Option<&Document> {
+    pub fn document(&self) -> Option<&Document> {
         match self {
             Preview::EditorDocument(doc) => Some(doc),
             Preview::Cached(CachedPreview::Document(doc)) => Some(doc),
@@ -184,11 +184,10 @@ pub fn push(&self, item: T) -> Result<(), InjectorShutdown> {
     }
 }
 
-type ColumnFormatFn<T, D> = for<'a> fn(&'a T, &'a D) -> Cell<'a>;
-
 pub struct Column<T, D> {
     name: Arc<str>,
-    format: ColumnFormatFn<T, D>,
+    /// Accept a closure, trading some performance against customization:
+    format: Arc<dyn for<'a> Fn(&'a T, &'a D) -> Cell<'a> + Send + Sync>,
     /// Whether the column should be passed to nucleo for matching and filtering.
     /// `DynamicPicker` uses this so that the dynamic column (for example regex in
     /// global search) is not used for filtering twice.
@@ -197,10 +196,14 @@ pub struct Column<T, D> {
 }
 
 impl<T, D> Column<T, D> {
-    pub fn new(name: impl Into<Arc<str>>, format: ColumnFormatFn<T, D>) -> Self {
+    pub fn new<F>(name: impl Into<Arc<str>>, format: F) -> Self
+    where
+        F: for<'a> Fn(&'a T, &'a D) -> Cell<'a> + Send + Sync,
+        F: 'static,
+    {
         Self {
             name: name.into(),
-            format,
+            format: Arc::new(format),
             filter: true,
             hidden: false,
         }
@@ -208,11 +211,9 @@ pub fn new(name: impl Into<Arc<str>>, format: ColumnFormatFn<T, D>) -> Self {
 
     /// A column which does not display any contents
     pub fn hidden(name: impl Into<Arc<str>>) -> Self {
-        let format = |_: &T, _: &D| unreachable!();
-
         Self {
             name: name.into(),
-            format,
+            format: Arc::new(|_: &T, _: &D| unreachable!()),
             filter: false,
             hidden: true,
         }
@@ -233,11 +234,132 @@ fn format_text<'a>(&self, item: &'a T, data: &'a D) -> Cow<'a, str> {
     }
 }
 
+const CACHE_READ_AHEAD_SIZE: usize = 1024;
+
+pub struct DocumentPreviewCache {
+    /// Caches paths to documents
+    preview_cache: HashMap<Arc<Path>, CachedPreview>,
+    read_buffer: Vec<u8>,
+}
+
+impl DocumentPreviewCache {
+    pub fn new() -> Self {
+        Self {
+            preview_cache: HashMap::new(),
+            read_buffer: Vec::with_capacity(CACHE_READ_AHEAD_SIZE),
+        }
+    }
+
+    /// Get (cached) preview for the currently selected item. If a document corresponding
+    /// to the path is already open in the editor, it is used instead.
+    pub fn get_preview<'picker, 'editor>(
+        &'picker mut self,
+        path: &Path,
+        editor: &'editor Editor,
+    ) -> Preview<'picker, 'editor> {
+        if let Some(doc) = editor.document_by_path(path) {
+            return Preview::EditorDocument(doc);
+        }
+
+        if self.preview_cache.contains_key(path) {
+            // NOTE: we use `HashMap::get_key_value` here instead of indexing so we can
+            // retrieve the `Arc<Path>` key. The `path` in scope here is a `&Path` and
+            // we can cheaply clone the key for the preview highlight handler.
+            let (_, preview) = self.preview_cache.get_key_value(path).unwrap();
+            // The preview_highlight_handler is called afterwards:
+            return Preview::Cached(preview);
+        }
+
+        let path: Arc<Path> = path.into();
+        let preview = std::fs::metadata(&path)
+            .and_then(|metadata| {
+                if metadata.is_dir() {
+                    let files = super::directory_content(&path)?;
+                    let file_names: Vec<_> = files
+                        .iter()
+                        .filter_map(|(path, is_dir)| {
+                            let name = path.file_name()?.to_string_lossy();
+                            if *is_dir {
+                                Some((format!("{}/", name), true))
+                            } else {
+                                Some((name.into_owned(), false))
+                            }
+                        })
+                        .collect();
+                    Ok(CachedPreview::Directory(file_names))
+                } else if metadata.is_file() {
+                    if metadata.len() > MAX_FILE_SIZE_FOR_PREVIEW {
+                        return Ok(CachedPreview::LargeFile);
+                    }
+                    let content_type = std::fs::File::open(&path).and_then(|file| {
+                        // Read up to 1kb to detect the content type
+                        let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
+                        let content_type = content_inspector::inspect(&self.read_buffer[..n]);
+                        self.read_buffer.clear();
+                        Ok(content_type)
+                    })?;
+                    if content_type.is_binary() {
+                        return Ok(CachedPreview::Binary);
+                    }
+                    let mut doc = Document::open(
+                        &path,
+                        None,
+                        false,
+                        editor.config.clone(),
+                        editor.syn_loader.clone(),
+                    )
+                    .or(Err(std::io::Error::new(
+                        std::io::ErrorKind::NotFound,
+                        "Cannot open document",
+                    )))?;
+                    let loader = editor.syn_loader.load();
+                    if let Some(language_config) = doc.detect_language_config(&loader) {
+                        doc.language = Some(language_config);
+                        // The preview_highlight_handler is called afterwards:
+                    }
+                    Ok(CachedPreview::Document(Box::new(doc)))
+                } else {
+                    Err(std::io::Error::new(
+                        std::io::ErrorKind::NotFound,
+                        "Neither a dir, nor a file",
+                    ))
+                }
+            })
+            .unwrap_or(CachedPreview::NotFound);
+        self.preview_cache.insert(path.clone(), preview);
+        Preview::Cached(&self.preview_cache[&path])
+    }
+
+    pub fn get_mut(&mut self, path: &Arc<Path>) -> Option<&mut CachedPreview> {
+        self.preview_cache.get_mut(path)
+    }
+
+    pub fn next(&self) -> Option<&CachedPreview> {
+        self.preview_cache.values().next()
+    }
+}
+
 /// Returns a new list of options to replace the contents of the picker
 /// when called with the current picker query,
 type DynQueryCallback<T, D> =
     fn(&str, &mut Editor, Arc<D>, &Injector<T, D>) -> BoxFuture<'static, anyhow::Result<()>>;
 
+enum PreviewDirection {
+    None,
+    Right,
+    Down,
+}
+
+impl PreviewDirection {
+    fn is_none(&self) -> bool {
+        if let Self::None = self {
+            true
+        } else {
+            false
+        }
+    }
+}
+
 pub struct Picker<T: 'static + Send + Sync, D: 'static> {
     columns: Arc<[Column<T, D>]>,
     primary_column: usize,
@@ -245,24 +367,22 @@ pub struct Picker<T: 'static + Send + Sync, D: 'static> {
     version: Arc<AtomicUsize>,
     matcher: Nucleo<T>,
 
-    /// Current height of the completions box
+    /// Current height of the completions box, update via render:
     completion_height: u16,
 
     cursor: u32,
     prompt: Prompt,
     query: PickerQuery,
 
-    /// Whether to show the preview panel (default true)
-    show_preview: bool,
+    /// Preview direction, defaults to right.
+    preview_direction: PreviewDirection,
     /// Constraints for tabular formatting
     widths: Vec<Constraint>,
 
     callback_fn: PickerCallback<T>,
 
     pub truncate_start: bool,
-    /// Caches paths to documents
-    preview_cache: HashMap<Arc<Path>, CachedPreview>,
-    read_buffer: Vec<u8>,
+    preview_cache: DocumentPreviewCache,
     /// Given an item in the picker, return the file path and line number to display.
     file_fn: Option<FileCallback<T>>,
     /// An event handler for syntax highlighting the currently previewed file.
@@ -365,7 +485,7 @@ fn with(
 
         let widths = columns
             .iter()
-            .map(|column| Constraint::Length(column.name.chars().count() as u16))
+            .map(|column| Constraint::Length(column.name.chars().count() as u16 + 1u16))
             .collect();
 
         let query = PickerQuery::new(columns.iter().map(|col| &col.name).cloned(), default_column);
@@ -380,12 +500,11 @@ fn with(
             prompt,
             query,
             truncate_start: true,
-            show_preview: true,
+            preview_direction: PreviewDirection::Right,
             callback_fn: Box::new(callback_fn),
             completion_height: 0,
             widths,
-            preview_cache: HashMap::new(),
-            read_buffer: Vec::with_capacity(1024),
+            preview_cache: DocumentPreviewCache::new(),
             file_fn: None,
             preview_highlight_handler: PreviewHighlightHandler::<T, D>::default().spawn(),
             dynamic_query_handler: None,
@@ -419,8 +538,44 @@ pub fn with_preview(
         self
     }
 
-    pub fn with_history_register(mut self, history_register: Option<char>) -> Self {
+    pub fn with_cached_previews(mut self, preview_cache: DocumentPreviewCache) -> Self {
+        self.preview_cache = preview_cache;
+        self
+    }
+
+    pub fn with_prefix(mut self, mut prefix: String) -> Self {
+        // Add a space to the end:
+        prefix.push(' ');
+        self.prompt.set_prefix(prefix);
+        self
+    }
+
+    pub fn with_history_register(
+        mut self,
+        history_register: Option<char>,
+        editor: &Editor,
+    ) -> Self {
         self.prompt.with_history_register(history_register);
+
+        // If the prompt has a history completion and is empty, accept it now
+        if let Some(completion) = self
+            .prompt
+            .first_history_completion(editor)
+            .filter(|_| self.prompt.line().is_empty())
+        {
+            // The percent character is used by the query language and needs to be
+            // escaped with a backslash.
+            let completion = if completion.contains('%') {
+                completion.replace('%', "\\%")
+            } else {
+                completion.into_owned()
+            };
+            self.prompt.set_line(completion.to_string(), editor);
+
+            // Inserting from the history register is a paste.
+            self.handle_prompt_change(true);
+        }
+
         self
     }
 
@@ -449,14 +604,18 @@ pub fn move_by(&mut self, amount: u32, direction: Direction) {
             return;
         }
 
-        match direction {
+        // Cap the limit to page first and last:
+        self.cursor = match direction {
             Direction::Forward => {
-                self.cursor = self.cursor.saturating_add(amount) % len;
-            }
-            Direction::Backward => {
-                self.cursor = self.cursor.saturating_add(len).saturating_sub(amount) % len;
+                let cursor = self.cursor.saturating_add(amount);
+                if cursor >= len {
+                    len - 1
+                } else {
+                    cursor
+                }
             }
-        }
+            Direction::Backward => self.cursor.saturating_sub(amount),
+        };
     }
 
     /// Move the cursor down by exactly one page. After the last page comes the first page.
@@ -498,15 +657,19 @@ fn primary_query(&self) -> Arc<str> {
     }
 
     fn header_height(&self) -> u16 {
-        if self.columns.len() > 1 {
-            1
-        } else {
+        if self.columns.iter().all(|c| c.hidden) {
             0
+        } else {
+            1
         }
     }
 
     pub fn toggle_preview(&mut self) {
-        self.show_preview = !self.show_preview;
+        self.preview_direction = match self.preview_direction {
+            PreviewDirection::None => PreviewDirection::Right,
+            PreviewDirection::Right => PreviewDirection::Down,
+            PreviewDirection::Down => PreviewDirection::None,
+        };
     }
 
     fn prompt_handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
@@ -574,92 +737,29 @@ fn get_preview<'picker, 'editor>(
         let current = self.selection()?;
         let (path_or_id, range) = (self.file_fn.as_ref()?)(editor, current)?;
 
-        match path_or_id {
+        let preview = match path_or_id {
             PathOrId::Path(path) => {
-                if let Some(doc) = editor.document_by_path(path) {
-                    return Some((Preview::EditorDocument(doc), range));
-                }
-
-                if self.preview_cache.contains_key(path) {
-                    // NOTE: we use `HashMap::get_key_value` here instead of indexing so we can
-                    // retrieve the `Arc<Path>` key. The `path` in scope here is a `&Path` and
-                    // we can cheaply clone the key for the preview highlight handler.
-                    let (path, preview) = self.preview_cache.get_key_value(path).unwrap();
-                    if matches!(preview, CachedPreview::Document(doc) if doc.syntax().is_none()) {
-                        helix_event::send_blocking(&self.preview_highlight_handler, path.clone());
-                    }
-                    return Some((Preview::Cached(preview), range));
-                }
-
-                let path: Arc<Path> = path.into();
-                let preview = std::fs::metadata(&path)
-                    .and_then(|metadata| {
-                        if metadata.is_dir() {
-                            let files = super::directory_content(&path)?;
-                            let file_names: Vec<_> = files
-                                .iter()
-                                .filter_map(|(path, is_dir)| {
-                                    let name = path.file_name()?.to_string_lossy();
-                                    if *is_dir {
-                                        Some((format!("{}/", name), true))
-                                    } else {
-                                        Some((name.into_owned(), false))
-                                    }
-                                })
-                                .collect();
-                            Ok(CachedPreview::Directory(file_names))
-                        } else if metadata.is_file() {
-                            if metadata.len() > MAX_FILE_SIZE_FOR_PREVIEW {
-                                return Ok(CachedPreview::LargeFile);
-                            }
-                            let content_type = std::fs::File::open(&path).and_then(|file| {
-                                // Read up to 1kb to detect the content type
-                                let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
-                                let content_type =
-                                    content_inspector::inspect(&self.read_buffer[..n]);
-                                self.read_buffer.clear();
-                                Ok(content_type)
-                            })?;
-                            if content_type.is_binary() {
-                                return Ok(CachedPreview::Binary);
-                            }
-                            let mut doc = Document::open(
-                                &path,
-                                None,
-                                false,
-                                editor.config.clone(),
-                                editor.syn_loader.clone(),
-                            )
-                            .or(Err(std::io::Error::new(
-                                std::io::ErrorKind::NotFound,
-                                "Cannot open document",
-                            )))?;
-                            let loader = editor.syn_loader.load();
-                            if let Some(language_config) = doc.detect_language_config(&loader) {
-                                doc.language = Some(language_config);
-                                // Asynchronously highlight the new document
-                                helix_event::send_blocking(
-                                    &self.preview_highlight_handler,
-                                    path.clone(),
-                                );
-                            }
-                            Ok(CachedPreview::Document(Box::new(doc)))
-                        } else {
-                            Err(std::io::Error::new(
-                                std::io::ErrorKind::NotFound,
-                                "Neither a dir, nor a file",
-                            ))
-                        }
-                    })
-                    .unwrap_or(CachedPreview::NotFound);
-                self.preview_cache.insert(path.clone(), preview);
-                Some((Preview::Cached(&self.preview_cache[&path]), range))
+                // TODO: avoid deeply copied 'to_owned'?
+                let path = path.to_owned();
+                self.preview_cache.get_preview(path.as_path(), editor)
             }
             PathOrId::Id(id) => {
                 let doc = editor.documents.get(&id).unwrap();
-                Some((Preview::EditorDocument(doc), range))
+                Preview::EditorDocument(doc)
+            }
+        };
+
+        if let Preview::Cached(CachedPreview::Document(doc)) = preview {
+            if doc.syntax().is_none() || doc.language.is_some() {
+                // Asynchronously highlight the new document
+                helix_event::send_blocking(
+                    &self.preview_highlight_handler,
+                    doc.path().unwrap().clone().into(),
+                );
             }
         }
+
+        Some((preview, range))
     }
 
     fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
@@ -823,8 +923,8 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
             .column_spacing(1)
             .widths(&self.widths);
 
-        // -- Header
-        if self.columns.len() > 1 {
+        // -- Header, always show; with `if true` to keep indent for git diff
+        if true {
             let active_column = self.query.active_column(self.prompt.position());
             let header_style = cx.editor.theme.get("ui.picker.header");
             let header_column_style = cx.editor.theme.get("ui.picker.header.column");
@@ -841,7 +941,9 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
                                 header_column_style
                             };
 
-                        Cell::from(Span::styled(Cow::from(&*column.name), style))
+                        // Add a prefix % to indicate you can filter with it
+                        let name = format!("%{}", &*column.name);
+                        Cell::from(Span::styled(Cow::from(name), style))
                     }
                 }))
                 .style(header_style),
@@ -998,22 +1100,29 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         // |         | |         |
         // +---------+ +---------+
 
-        let render_preview =
-            self.show_preview && self.file_fn.is_some() && area.width > MIN_AREA_WIDTH_FOR_PREVIEW;
-
-        let picker_width = if render_preview {
-            area.width / 2
-        } else {
-            area.width
-        };
-
-        let picker_area = area.with_width(picker_width);
-        self.render_picker(picker_area, surface, cx);
+        // Reset the height:
+        self.completion_height = area.height;
 
-        if render_preview {
-            let preview_area = area.clip_left(picker_width);
-            self.render_preview(preview_area, surface, cx);
+        match (&self.file_fn, &self.preview_direction) {
+            (None, _) | (_, PreviewDirection::None) => self.render_picker(area, surface, cx),
+            (_, PreviewDirection::Right) if area.width > MIN_AREA_WIDTH_FOR_PREVIEW => {
+                let width = area.width / 2;
+                self.render_picker(area.with_width(width), surface, cx);
+                self.render_preview(area.clip_left(width), surface, cx);
+            }
+            _ => {
+                let height = area.height / 2;
+                self.render_picker(area.with_height(height), surface, cx);
+                self.render_preview(area.clip_top(height), surface, cx);
+                self.preview_direction = PreviewDirection::Down;
+                self.completion_height = height;
+            }
         }
+
+        // Fixup, TODO: ugly workaround...
+        self.completion_height = self
+            .completion_height
+            .saturating_sub(4 + self.header_height());
     }
 
     fn handle_event(&mut self, event: &Event, ctx: &mut Context) -> EventResult {
@@ -1075,39 +1184,19 @@ fn handle_event(&mut self, event: &Event, ctx: &mut Context) -> EventResult {
                 }
             }
             key!(Enter) => {
-                // If the prompt has a history completion and is empty, use enter to accept
-                // that completion
-                if let Some(completion) = self
-                    .prompt
-                    .first_history_completion(ctx.editor)
-                    .filter(|_| self.prompt.line().is_empty())
-                {
-                    // The percent character is used by the query language and needs to be
-                    // escaped with a backslash.
-                    let completion = if completion.contains('%') {
-                        completion.replace('%', "\\%")
-                    } else {
-                        completion.into_owned()
-                    };
-                    self.prompt.set_line(completion, ctx.editor);
-
-                    // Inserting from the history register is a paste.
-                    self.handle_prompt_change(true);
-                } else {
-                    if let Some(option) = self.selection() {
-                        (self.callback_fn)(ctx, option, Action::Replace);
-                    }
-                    if let Some(history_register) = self.prompt.history_register() {
-                        if let Err(err) = ctx
-                            .editor
-                            .registers
-                            .push(history_register, self.primary_query().to_string())
-                        {
-                            ctx.editor.set_error(err.to_string());
-                        }
+                if let Some(option) = self.selection() {
+                    (self.callback_fn)(ctx, option, Action::Replace);
+                }
+                if let Some(history_register) = self.prompt.history_register() {
+                    if let Err(err) = ctx
+                        .editor
+                        .registers
+                        .push(history_register, self.primary_query().to_string())
+                    {
+                        ctx.editor.set_error(err.to_string());
                     }
-                    return close_fn(self);
                 }
+                return close_fn(self);
             }
             ctrl!('s') => {
                 if let Some(option) = self.selection() {
@@ -1138,8 +1227,9 @@ fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
         let inner = block.inner(area);
 
         // prompt area
-        let render_preview =
-            self.show_preview && self.file_fn.is_some() && area.width > MIN_AREA_WIDTH_FOR_PREVIEW;
+        let render_preview = !self.preview_direction.is_none()
+            && self.file_fn.is_some()
+            && area.width > MIN_AREA_WIDTH_FOR_PREVIEW;
 
         let picker_width = if render_preview {
             area.width / 2
@@ -1151,11 +1241,6 @@ fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
         self.prompt.cursor(area, editor)
     }
 
-    fn required_size(&mut self, (width, height): (u16, u16)) -> Option<(u16, u16)> {
-        self.completion_height = height.saturating_sub(4 + self.header_height());
-        Some((width, height))
-    }
-
     fn id(&self) -> Option<&'static str> {
         Some(ID)
     }
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index ff4ca1fc..fd0f3efd 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -31,6 +31,7 @@
 pub struct Prompt {
     prompt: Cow<'static, str>,
     line: String,
+    prefix: String,
     cursor: usize,
     // Fields used for Component callbacks and rendering:
     line_area: Rect,
@@ -89,6 +90,7 @@ pub fn new(
         Self {
             prompt,
             line: String::new(),
+            prefix: String::new(),
             cursor: 0,
             line_area: Rect::default(),
             anchor: 0,
@@ -124,6 +126,10 @@ pub fn set_line(&mut self, line: String, editor: &Editor) {
         self.recalculate_completion(editor);
     }
 
+    pub fn set_prefix(&mut self, prefix: String) {
+        self.prefix = prefix;
+    }
+
     pub fn with_language(
         mut self,
         language: &'static str,
@@ -332,6 +338,13 @@ pub fn kill_to_end_of_line(&mut self, editor: &Editor) {
         self.recalculate_completion(editor);
     }
 
+    fn kill_whole_line(&mut self, editor: &Editor) {
+        self.line = String::new();
+        self.cursor = 0;
+
+        self.recalculate_completion(editor);
+    }
+
     pub fn clear(&mut self, editor: &Editor) {
         self.line.clear();
         self.cursor = 0;
@@ -509,10 +522,11 @@ pub fn render_prompt(&mut self, area: Rect, surface: &mut Surface, cx: &mut Cont
         let line = area.height - 1;
         surface.clear_with(area.clip_top(line), background);
         // render buffer text
-        surface.set_string(area.x, area.y + line, &self.prompt, prompt_color);
-
+        let prompt_text = format!("{}{}", self.prefix, self.prompt);
+        let prompt_len = self.prefix.len() + self.prompt.len();
+        surface.set_string(area.x, area.y + line, &prompt_text, prompt_color);
         self.line_area = area
-            .clip_left(self.prompt.len() as u16)
+            .clip_left(prompt_len as u16)
             .clip_top(line)
             .clip_right(2);
 
@@ -642,6 +656,10 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
                 self.kill_to_start_of_line(cx.editor);
                 (self.callback_fn)(cx, &self.line, PromptEvent::Update);
             }
+            alt!('k') => {
+                self.kill_whole_line(cx.editor);
+                (self.callback_fn)(cx, &self.line, PromptEvent::Update);
+            }
             ctrl!('h') | key!(Backspace) | shift!(Backspace) => {
                 self.delete_char_backwards(cx.editor);
                 (self.callback_fn)(cx, &self.line, PromptEvent::Update);
@@ -784,6 +802,7 @@ fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
         }
 
         let line = area.height as usize - 1;
+        col += self.prefix.len();
 
         (
             Some(Position::new(area.y as usize + line, col)),
diff --git a/helix-term/src/ui/statusline.rs b/helix-term/src/ui/statusline.rs
index ea3d27bd..a5f4e40f 100644
--- a/helix-term/src/ui/statusline.rs
+++ b/helix-term/src/ui/statusline.rs
@@ -158,6 +158,7 @@ fn get_render_function<'a, F>(element_id: StatusLineElementID) -> impl Fn(&mut R
         helix_view::editor::StatusLineElement::Spacer => render_spacer,
         helix_view::editor::StatusLineElement::VersionControl => render_version_control,
         helix_view::editor::StatusLineElement::Register => render_register,
+        helix_view::editor::StatusLineElement::SearchConfig => render_search_config,
     }
 }
 
@@ -573,3 +574,22 @@ fn render_file_indent_style<'a, F>(context: &mut RenderContext<'a>, write: F)
         },
     );
 }
+
+fn render_search_config<'a, F>(context: &mut RenderContext<'a>, write: F)
+where
+    F: Fn(&mut RenderContext<'a>, Span<'a>) + Copy,
+{
+    // TODO: place to ui/editor.rs using `status_msg`?
+    let sc = &context.editor.config().search;
+    write(
+        context,
+        format!(
+            " ({}{}{}{}) ",
+            if sc.regex { 'r' } else { ' ' },
+            if sc.case_sensitive { 'c' } else { ' ' },
+            if sc.smart_case { 's' } else { ' ' },
+            if sc.whole_word { 'w' } else { ' ' }
+        )
+        .into(),
+    )
+}
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 2fff2347..9d3f9f16 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -1834,6 +1834,26 @@ pub fn remove_language_server_by_name(&mut self, name: &str) -> Option<Arc<Clien
         self.language_servers.remove(name)
     }
 
+    // TODO: Merge with language_servers_with_feature:
+    pub fn arc_language_servers_with_feature(
+        &self,
+        feature: LanguageServerFeature,
+    ) -> impl Iterator<Item = Arc<helix_lsp::Client>> + '_ {
+        self.language_config().into_iter().flat_map(move |config| {
+            config.language_servers.iter().filter_map(move |features| {
+                let ls = self.language_servers.get(&features.name)?.clone();
+                if ls.is_initialized()
+                    && ls.supports_feature(feature)
+                    && features.has_feature(feature)
+                {
+                    Some(ls)
+                } else {
+                    None
+                }
+            })
+        })
+    }
+
     pub fn language_servers_with_feature(
         &self,
         feature: LanguageServerFeature,
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index 27dc4523..5f0842b2 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -497,6 +497,12 @@ pub struct SearchConfig {
     pub smart_case: bool,
     /// Whether the search should wrap after depleting the matches. Default to true.
     pub wrap_around: bool,
+    /// Forced case sensitive. Defaults to false, the smart_case is respected when false.
+    pub case_sensitive: bool,
+    /// Search whole word. Defaults to false.
+    pub whole_word: bool,
+    /// Use regex all the places. Defaults to true.
+    pub regex: bool,
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
@@ -528,6 +534,7 @@ fn default() -> Self {
                 E::Diagnostics,
                 E::Selections,
                 E::Register,
+                E::SearchConfig,
                 E::Position,
                 E::FileEncoding,
             ],
@@ -625,6 +632,9 @@ pub enum StatusLineElement {
 
     /// Indicator for selected register
     Register,
+
+    /// Indicator for the search config (sensetive or else), TODO: global
+    SearchConfig,
 }
 
 // Cursor shape is read and used on every rendered frame and so needs
@@ -1044,6 +1054,9 @@ fn default() -> Self {
         Self {
             wrap_around: true,
             smart_case: true,
+            case_sensitive: false,
+            whole_word: false,
+            regex: true,
         }
     }
 }
@@ -1470,6 +1483,13 @@ pub fn move_path(&mut self, old_path: &Path, new_path: &Path) -> io::Result<()>
         Ok(())
     }
 
+    // TODO: current_buffer().directory()
+    pub fn current_buffer_directory(&self) -> Option<PathBuf> {
+        doc!(self)
+            .path()
+            .and_then(|path| path.parent().map(|path| path.to_path_buf()))
+    }
+
     pub fn set_doc_path(&mut self, doc_id: DocumentId, path: &Path) {
         let doc = doc_mut!(self, &doc_id);
         let old_path = doc.path();
diff --git a/runtime/queries/c/textobjects.scm b/runtime/queries/c/textobjects.scm
index 63ec4a56..26fd35d9 100644
--- a/runtime/queries/c/textobjects.scm
+++ b/runtime/queries/c/textobjects.scm
@@ -1,3 +1,6 @@
+(function_declarator
+  declarator: (identifier) @function_name.inside)
+
 (function_definition
   body: (_) @function.inside) @function.around
 
diff --git a/runtime/queries/python/textobjects.scm b/runtime/queries/python/textobjects.scm
index 2b9556fc..85cb1241 100644
--- a/runtime/queries/python/textobjects.scm
+++ b/runtime/queries/python/textobjects.scm
@@ -1,4 +1,5 @@
 (function_definition
+  name: (identifier) @function_name.inside
   body: (block)? @function.inside) @function.around
 
 (class_definition
diff --git a/runtime/queries/rust/textobjects.scm b/runtime/queries/rust/textobjects.scm
index e9ecb8ba..40404773 100644
--- a/runtime/queries/rust/textobjects.scm
+++ b/runtime/queries/rust/textobjects.scm
@@ -1,4 +1,5 @@
 (function_item
+  name: (_) @function_name.inside
   body: (_) @function.inside) @function.around
 
 (closure_expression
