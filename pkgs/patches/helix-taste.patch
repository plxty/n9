diff --git a/flake.nix b/flake.nix
index 1fda3fa9..6466cd51 100644
--- a/flake.nix
+++ b/flake.nix
@@ -187,9 +187,4 @@
         inherit (self.packages.${final.system}) helix;
       };
     };
-
-  nixConfig = {
-    extra-substituters = ["https://helix.cachix.org"];
-    extra-trusted-public-keys = ["helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs="];
-  };
 }
diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index 76de6362..846fa46a 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -527,6 +527,12 @@ pub fn range_bounds(&self) -> impl Iterator<Item = helix_stdx::Range> + '_ {
         self.ranges.iter().map(|&range| range.into())
     }
 
+    pub fn is_single_grapheme(&self, text: RopeSlice) -> bool {
+        self.ranges()
+            .get(0)
+            .is_some_and(|r| r.is_single_grapheme(text))
+    }
+
     pub fn primary_index(&self) -> usize {
         self.primary_index
     }
diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index cc1c4ce8..4b750c74 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -661,6 +661,10 @@ pub(crate) async fn initialize(&self, enable_snippets: bool) -> Result<lsp::Init
                         dynamic_registration: Some(false),
                         resolve_support: None,
                     }),
+                    document_symbol: Some(lsp::DocumentSymbolClientCapabilities {
+                        hierarchical_document_symbol_support: Some(true),
+                        ..Default::default()
+                    }),
                     ..Default::default()
                 }),
                 window: Some(lsp::WindowClientCapabilities {
diff --git a/helix-lsp/src/lib.rs b/helix-lsp/src/lib.rs
index fd5cdb8b..0fcc03e1 100644
--- a/helix-lsp/src/lib.rs
+++ b/helix-lsp/src/lib.rs
@@ -126,21 +126,18 @@ pub fn diagnostic_to_lsp_diagnostic(
         }
     }
 
-    /// Converts [`lsp::Position`] to a position in the document.
-    ///
-    /// Returns `None` if position.line is out of bounds or an overflow occurs
-    pub fn lsp_pos_to_pos(
+    pub fn lsp_pos_to_line(
         doc: &Rope,
         pos: lsp::Position,
         offset_encoding: OffsetEncoding,
-    ) -> Option<usize> {
+    ) -> Option<std::ops::Range<usize>> {
         let pos_line = pos.line as usize;
         if pos_line > doc.len_lines() - 1 {
             // If it extends past the end, truncate it to the end. This is because the
             // way the LSP describes the range including the last newline is by
             // specifying a line number after what we would call the last line.
             log::warn!("LSP position {pos:?} out of range assuming EOF");
-            return Some(doc.len_chars());
+            return None;
         }
 
         // We need to be careful here to fully comply ith the LSP spec.
@@ -189,6 +186,22 @@ pub fn lsp_pos_to_pos(
             }
         };
 
+        Some(line)
+    }
+
+    /// Converts [`lsp::Position`] to a position in the document.
+    ///
+    /// Returns `None` if position.line is out of bounds or an overflow occurs
+    pub fn lsp_pos_to_pos(
+        doc: &Rope,
+        pos: lsp::Position,
+        offset_encoding: OffsetEncoding,
+    ) -> Option<usize> {
+        let line = match lsp_pos_to_line(doc, pos, offset_encoding) {
+            Some(line) => line,
+            None => return Some(doc.len_chars()),
+        };
+
         // The LSP spec demands that the offset is capped to the end of the line
         let pos = line
             .start
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 52efcf22..eec8247a 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -59,7 +59,10 @@
     compositor::{self, Component, Compositor},
     filter_picker_entry,
     job::Callback,
-    ui::{self, overlay::overlaid, Picker, PickerColumn, Popup, Prompt, PromptEvent},
+    ui::{
+        self, overlay::overlaid, transform_search_query, Picker, PickerColumn, Popup, Prompt,
+        PromptEvent,
+    },
 };
 
 use crate::job::{self, Jobs};
@@ -543,6 +546,8 @@ pub fn doc(&self) -> &str {
         select_textobject_inner, "Select inside object",
         goto_next_function, "Goto next function",
         goto_prev_function, "Goto previous function",
+        goto_next_function_name, "Goto next function name",
+        goto_prev_function_name, "Goto previous function name",
         goto_next_class, "Goto next type definition",
         goto_prev_class, "Goto previous type definition",
         goto_next_parameter, "Goto next parameter",
@@ -587,6 +592,8 @@ pub fn doc(&self) -> &str {
         extend_to_word, "Extend to a two-character label",
         goto_next_tabstop, "goto next snippet placeholder",
         goto_prev_tabstop, "goto next snippet placeholder",
+        goto_word_definition, "Definition of a two-character label",
+        goto_word_reference, "Reference of a two-character label",
     );
 }
 
@@ -2214,11 +2221,8 @@ fn search_next_or_prev_impl(cx: &mut Context, movement: Movement, direction: Dir
     let scrolloff = config.scrolloff;
     if let Some(query) = cx.editor.registers.first(register, cx.editor) {
         let search_config = &config.search;
-        let case_insensitive = if search_config.smart_case {
-            !query.chars().any(char::is_uppercase)
-        } else {
-            false
-        };
+        let (query, case_insensitive) = transform_search_query(search_config, query.as_ref());
+
         let wrap_around = search_config.wrap_around;
         if let Ok(regex) = rope::RegexBuilder::new()
             .syntax(
@@ -2270,6 +2274,10 @@ fn search_selection_detect_word_boundaries(cx: &mut Context) {
 }
 
 fn search_selection_impl(cx: &mut Context, detect_word_boundaries: bool) {
+    if cx.count.is_none() {
+        do_expand_selection(cx.editor, true);
+    }
+
     fn is_at_word_start(text: RopeSlice, index: usize) -> bool {
         let ch = text.char(index);
         if index == 0 {
@@ -2382,13 +2390,14 @@ fn new(path: &Path, line_num: usize) -> Self {
     }
 
     struct GlobalSearchConfig {
-        smart_case: bool,
+        search_config: helix_view::editor::SearchConfig,
         file_picker_config: helix_view::editor::FilePickerConfig,
     }
 
+    // TODO: try to avoid copy with Rc or else?
     let config = cx.editor.config();
     let config = GlobalSearchConfig {
-        smart_case: config.search.smart_case,
+        search_config: config.search.clone(),
         file_picker_config: config.file_picker.clone(),
     };
 
@@ -2419,9 +2428,11 @@ struct GlobalSearchConfig {
             .map(|doc| (doc.path().cloned(), doc.text().to_owned()))
             .collect();
 
+        // TODO: better smart-case?
+        let (query, case_insensitive) = transform_search_query(&config.search_config, query);
         let matcher = match RegexMatcherBuilder::new()
-            .case_smart(config.smart_case)
-            .build(query)
+            .case_insensitive(case_insensitive)
+            .build(query.as_ref())
         {
             Ok(matcher) => {
                 // Clear any "Failed to compile regex" errors out of the statusline.
@@ -2564,7 +2575,7 @@ struct GlobalSearchConfig {
     .with_preview(|_editor, FileResult { path, line_num, .. }| {
         Some((path.as_path().into(), Some((*line_num, *line_num))))
     })
-    .with_history_register(Some(reg))
+    .with_history_register(Some(reg), cx.editor)
     .with_dynamic_query(get_files, Some(275));
 
     cx.push_layer(Box::new(overlaid(picker)));
@@ -2959,11 +2970,7 @@ fn file_picker(cx: &mut Context) {
 }
 
 fn file_picker_in_current_buffer_directory(cx: &mut Context) {
-    let doc_dir = doc!(cx.editor)
-        .path()
-        .and_then(|path| path.parent().map(|path| path.to_path_buf()));
-
-    let path = match doc_dir {
+    let path = match cx.editor.current_buffer_directory() {
         Some(path) => path,
         None => {
             cx.editor.set_error("current buffer has no path or parent");
@@ -5151,14 +5158,18 @@ fn reverse_selection_contents(cx: &mut Context) {
 
 // tree sitter node selection
 
-fn expand_selection(cx: &mut Context) {
-    let motion = |editor: &mut Editor| {
+fn do_expand_selection(editor: &mut Editor, skip_if_selected: bool) {
+    if true {
         let (view, doc) = current!(editor);
 
         if let Some(syntax) = doc.syntax() {
             let text = doc.text().slice(..);
 
             let current_selection = doc.selection(view.id);
+            if skip_if_selected && !current_selection.is_single_grapheme(text) {
+                return;
+            }
+
             let selection = object::expand_selection(syntax, text, current_selection.clone());
 
             // check if selection is different from the last one
@@ -5170,7 +5181,11 @@ fn expand_selection(cx: &mut Context) {
             }
         }
     };
-    cx.editor.apply_motion(motion);
+}
+
+fn expand_selection(cx: &mut Context) {
+    cx.editor
+        .apply_motion(|editor: &mut Editor| do_expand_selection(editor, false));
 }
 
 fn shrink_selection(cx: &mut Context) {
@@ -5593,6 +5608,14 @@ fn goto_prev_function(cx: &mut Context) {
     goto_ts_object_impl(cx, "function", Direction::Backward)
 }
 
+fn goto_next_function_name(cx: &mut Context) {
+    goto_ts_object_impl(cx, "function_name", Direction::Forward)
+}
+
+fn goto_prev_function_name(cx: &mut Context) {
+    goto_ts_object_impl(cx, "function_name", Direction::Backward)
+}
+
 fn goto_next_class(cx: &mut Context) {
     goto_ts_object_impl(cx, "class", Direction::Forward)
 }
@@ -6371,14 +6394,27 @@ fn replay_macro(cx: &mut Context) {
 }
 
 fn goto_word(cx: &mut Context) {
-    jump_to_word(cx, Movement::Move)
+    jump_to_word(cx, Movement::Move, None)
 }
 
 fn extend_to_word(cx: &mut Context) {
-    jump_to_word(cx, Movement::Extend)
+    jump_to_word(cx, Movement::Extend, None)
+}
+
+fn goto_word_reference(cx: &mut Context) {
+    jump_to_word(cx, Movement::Move, Some(goto_reference))
 }
 
-fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
+fn goto_word_definition(cx: &mut Context) {
+    jump_to_word(cx, Movement::Move, Some(goto_definition))
+}
+
+fn jump_to_label(
+    cx: &mut Context,
+    labels: Vec<Range>,
+    behaviour: Movement,
+    do_next: Option<fn(&mut Context)>,
+) {
     let doc = doc!(cx.editor);
     let alphabet = &cx.editor.config().jump_label_alphabet;
     if labels.is_empty() {
@@ -6457,15 +6493,23 @@ fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
                     };
                     Range::new(anchor, range.head)
                 } else {
+                    // Movement, save to jumplist before we jump
+                    let (view, doc) = current!(cx.editor);
+                    push_jump(view, doc);
+
                     range.with_direction(Direction::Forward)
                 };
                 doc_mut!(cx.editor, &doc).set_selection(view, range.into());
+
+                if let Some(func) = do_next {
+                    func(cx);
+                }
             }
         });
     });
 }
 
-fn jump_to_word(cx: &mut Context, behaviour: Movement) {
+fn jump_to_word(cx: &mut Context, behaviour: Movement, do_next: Option<fn(&mut Context)>) {
     // Calculate the jump candidates: ranges for any visible words with two or
     // more characters.
     let alphabet = &cx.editor.config().jump_label_alphabet;
@@ -6552,5 +6596,5 @@ fn jump_to_word(cx: &mut Context, behaviour: Movement) {
             break;
         }
     }
-    jump_to_label(cx, words, behaviour)
+    jump_to_label(cx, words, behaviour, do_next)
 }
diff --git a/helix-term/src/commands/lsp.rs b/helix-term/src/commands/lsp.rs
index fcc0333e..e8357c9a 100644
--- a/helix-term/src/commands/lsp.rs
+++ b/helix-term/src/commands/lsp.rs
@@ -5,7 +5,7 @@
         self, CodeAction, CodeActionOrCommand, CodeActionTriggerKind, DiagnosticSeverity,
         NumberOrString,
     },
-    util::{diagnostic_to_lsp_diagnostic, lsp_range_to_range, range_to_lsp_range},
+    util::{diagnostic_to_lsp_diagnostic, lsp_pos_to_line, lsp_range_to_range, range_to_lsp_range},
     Client, LanguageServerId, OffsetEncoding,
 };
 use tokio_stream::StreamExt;
@@ -28,12 +28,15 @@
 use crate::{
     compositor::{self, Compositor},
     job::Callback,
-    ui::{self, overlay::overlaid, FileLocation, Picker, Popup, PromptEvent},
+    ui::{
+        self, overlay::overlaid, picker::DocumentPreviewCache, FileLocation, Picker, Popup,
+        PromptEvent,
+    },
 };
 
 use std::{
     cmp::Ordering,
-    collections::{BTreeMap, HashSet},
+    collections::{BTreeMap, HashMap, HashSet},
     fmt::Display,
     future::Future,
     path::Path,
@@ -66,6 +69,7 @@ macro_rules! language_server_with_feature {
 struct Location {
     uri: Uri,
     range: lsp::Range,
+    kind: Option<lsp::DocumentHighlightKind>,
 }
 
 fn lsp_location_to_location(location: lsp::Location) -> Option<Location> {
@@ -79,12 +83,22 @@ fn lsp_location_to_location(location: lsp::Location) -> Option<Location> {
     Some(Location {
         uri,
         range: location.range,
+        kind: None,
     })
 }
 
+type LocationKind = (lsp::Location, Option<lsp::DocumentHighlightKind>);
+
+fn lsp_location_to_location_with_kind(location_and_kind: LocationKind) -> Option<Location> {
+    let mut location = lsp_location_to_location(location_and_kind.0)?;
+    location.kind = location_and_kind.1;
+    Some(location)
+}
+
 struct SymbolInformationItem {
     location: Location,
     symbol: lsp::SymbolInformation,
+    signature: Option<String>,
     offset_encoding: OffsetEncoding,
 }
 
@@ -220,6 +234,7 @@ fn diag_picker(
                     location: Location {
                         uri: uri.clone(),
                         range: diag.range,
+                        kind: None,
                     },
                     diag,
                     offset_encoding: ls.offset_encoding(),
@@ -303,25 +318,35 @@ fn nested_to_flat(
         uri: &Uri,
         symbol: lsp::DocumentSymbol,
         offset_encoding: OffsetEncoding,
+        prefix: &str,
     ) {
+        // TODO: &mut String for performance? with push/pop
+        let mut name = prefix.to_string();
+        if !name.is_empty() {
+            name.push_str("::"); // cpp style
+        }
+        name.push_str(symbol.name.as_str());
+
         #[allow(deprecated)]
         list.push(SymbolInformationItem {
             symbol: lsp::SymbolInformation {
-                name: symbol.name,
+                name: name.clone(),
                 kind: symbol.kind,
                 tags: symbol.tags,
                 deprecated: symbol.deprecated,
                 location: lsp::Location::new(file.uri.clone(), symbol.selection_range),
                 container_name: None,
             },
+            signature: symbol.detail,
             offset_encoding,
             location: Location {
                 uri: uri.clone(),
                 range: symbol.selection_range,
+                kind: None,
             },
         });
         for child in symbol.children.into_iter().flatten() {
-            nested_to_flat(list, file, uri, child, offset_encoding);
+            nested_to_flat(list, file, uri, child, offset_encoding, name.as_str());
         }
     }
     let doc = doc!(cx.editor);
@@ -355,11 +380,14 @@ fn nested_to_flat(
                             location: Location {
                                 uri: doc_uri.clone(),
                                 range: symbol.location.range,
+                                kind: None,
                             },
                             symbol,
+                            signature: None,
                             offset_encoding,
                         })
                         .collect(),
+                    // for rust-analyzer: `snap.config.hierarchical_symbols` must be enabled
                     lsp::DocumentSymbolResponse::Nested(symbols) => {
                         let mut flat_symbols = Vec::new();
                         for symbol in symbols {
@@ -369,6 +397,7 @@ fn nested_to_flat(
                                 &doc_uri,
                                 symbol,
                                 offset_encoding,
+                                "",
                             )
                         }
                         flat_symbols
@@ -402,6 +431,14 @@ fn nested_to_flat(
                 ui::PickerColumn::new("name", |item: &SymbolInformationItem, _| {
                     item.symbol.name.as_str().into()
                 }),
+                // Signature of the symbol
+                ui::PickerColumn::new("signature", |item: &SymbolInformationItem, _| {
+                    if let Some(ref signature) = item.signature {
+                        signature.to_string().into()
+                    } else {
+                        "".into()
+                    }
+                }),
             ];
 
             let picker = Picker::new(
@@ -467,8 +504,10 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
                                     location: Location {
                                         uri,
                                         range: symbol.location.range,
+                                        kind: None,
                                     },
                                     symbol,
+                                    signature: None,
                                     offset_encoding,
                                 })
                             })
@@ -858,6 +897,7 @@ fn goto_impl(
     compositor: &mut Compositor,
     locations: Vec<Location>,
     offset_encoding: OffsetEncoding,
+    show_kind: bool,
 ) {
     let cwdir = helix_stdx::env::current_working_dir();
 
@@ -867,9 +907,37 @@ fn goto_impl(
         }
         [] => unreachable!("`locations` should be non-empty for `goto_impl`"),
         _locations => {
-            let columns = [ui::PickerColumn::new(
-                "location",
-                |item: &Location, cwdir: &std::path::PathBuf| {
+            // Manage the preview cache ourselves to speed up a little:
+            let mut preview_cache = DocumentPreviewCache::new();
+
+            // [Location] -> [(Location, Line?)]
+            let mut symbol_name: Option<String> = None;
+            let locations = locations
+                .iter()
+                .map(|loc| {
+                    let line = loc.uri.as_path().and_then(|path| {
+                        let preview = preview_cache.get_preview(path, editor);
+                        let doc = preview.document()?;
+
+                        // Extract symbol name from better displaying, any of it is fine:
+                        if symbol_name.is_none() {
+                            let range = lsp_range_to_range(doc.text(), loc.range, offset_encoding)?;
+                            symbol_name =
+                                Some(doc.text().get_slice(range.anchor..range.head)?.to_string());
+                        }
+
+                        // Extract all the relative lines, we do it here to avoid Sync:
+                        let range = lsp_pos_to_line(doc.text(), loc.range.start, offset_encoding)?;
+                        Some(doc.text().get_slice(range)?.as_str()?.trim().to_string())
+                    });
+                    (loc.clone(), line)
+                })
+                .collect::<Vec<_>>();
+
+            let mut columns = Vec::with_capacity(3);
+            columns.push(ui::PickerColumn::new(
+                "path",
+                |(item, _): &(Location, Option<String>), cwdir: &std::path::PathBuf| {
                     let path = if let Some(path) = item.uri.as_path() {
                         path.strip_prefix(cwdir).unwrap_or(path).to_string_lossy()
                     } else {
@@ -878,12 +946,40 @@ fn goto_impl(
 
                     format!("{path}:{}", item.range.start.line + 1).into()
                 },
-            )];
+            ));
+            if show_kind {
+                columns.push(ui::PickerColumn::new(
+                    "kind",
+                    |(item, _): &(Location, Option<String>), _: &std::path::PathBuf| {
+                        match item.kind {
+                            None => "",
+                            Some(k) if k == lsp::DocumentHighlightKind::TEXT => "text",
+                            Some(k) if k == lsp::DocumentHighlightKind::READ => "read",
+                            Some(k) if k == lsp::DocumentHighlightKind::WRITE => "write",
+                            Some(_) => "unknown",
+                        }
+                        .into()
+                    },
+                ))
+            }
+            columns.push(ui::PickerColumn::new(
+                format!("line {}", symbol_name.unwrap_or_default()),
+                |(_, line): &(Location, Option<String>), _: &std::path::PathBuf| {
+                    line.clone().unwrap_or_default().into()
+                },
+            ));
 
-            let picker = Picker::new(columns, 0, locations, cwdir, move |cx, location, action| {
-                jump_to_location(cx.editor, location, offset_encoding, action)
-            })
-            .with_preview(move |_editor, location| location_to_file_location(location));
+            let picker = Picker::new(
+                columns,
+                0,
+                locations,
+                cwdir,
+                move |cx, (location, _), action| {
+                    jump_to_location(cx.editor, location, offset_encoding, action)
+                },
+            )
+            .with_cached_previews(preview_cache)
+            .with_preview(move |_editor, (location, _)| location_to_file_location(location));
             compositor.push(Box::new(overlaid(picker)));
         }
     }
@@ -928,7 +1024,7 @@ fn goto_single_impl<P, F>(cx: &mut Context, feature: LanguageServerFeature, requ
             if items.is_empty() {
                 editor.set_error("No definition found.");
             } else {
-                goto_impl(editor, compositor, items, offset_encoding);
+                goto_impl(editor, compositor, items, offset_encoding, false);
             }
         },
     );
@@ -985,18 +1081,69 @@ pub fn goto_reference(cx: &mut Context) {
         )
         .unwrap();
 
+    // For marking read/write:
+    let hl_language_server = doc
+        .arc_language_servers_with_feature(LanguageServerFeature::DocumentHighlight)
+        .next();
+
+    // TODO: Make document an injector (update later)
+    let future = async move {
+        if hl_language_server.is_none() {
+            return future.await;
+        }
+        let hl_language_server = hl_language_server.unwrap();
+        let gr_result = serde_json::from_value::<Option<Vec<lsp::Location>>>(future.await?)?
+            .unwrap_or_default();
+
+        // TODO: Simplify...
+        let mut highlights =
+            HashMap::<(url::Url, lsp::Position), Option<lsp::DocumentHighlightKind>>::new();
+        let mut result = Vec::<LocationKind>::new();
+
+        for loc in gr_result {
+            let highlight = (loc.uri.clone(), loc.range.start);
+            let hl_result = if let Some(r) = highlights.get(&highlight) {
+                *r
+            } else {
+                let result = hl_language_server
+                    .text_document_document_highlight(
+                        lsp::TextDocumentIdentifier::new(loc.uri.clone()),
+                        loc.range.start,
+                        None,
+                    )
+                    .unwrap()
+                    .await;
+                // clangd requries a `DidOpen` for DocumentHighlight, but opening all files in
+                // reference may be way slower, and we now ignores it... TODO: solution!
+                if let Ok(result) = result {
+                    let result =
+                        serde_json::from_value::<Option<Vec<lsp::DocumentHighlight>>>(result)?;
+                    for hl in result.unwrap_or_default() {
+                        highlights.insert((loc.uri.clone(), hl.range.start), hl.kind);
+                    }
+                    *highlights.get(&highlight).unwrap_or(&None)
+                } else {
+                    None
+                }
+            };
+
+            result.push((loc, hl_result));
+        }
+        Ok(serde_json::to_value(result)?)
+    };
+
     cx.callback(
         future,
-        move |editor, compositor, response: Option<Vec<lsp::Location>>| {
+        move |editor, compositor, response: Option<Vec<LocationKind>>| {
             let items: Vec<Location> = response
                 .into_iter()
                 .flatten()
-                .flat_map(lsp_location_to_location)
+                .flat_map(lsp_location_to_location_with_kind)
                 .collect();
             if items.is_empty() {
                 editor.set_error("No references found.");
             } else {
-                goto_impl(editor, compositor, items, offset_encoding);
+                goto_impl(editor, compositor, items, offset_encoding, true);
             }
         },
     );
diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index 4a2546d7..54a8fc0d 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -139,6 +139,32 @@ fn open(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     Ok(())
 }
 
+fn open_in_current(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    ensure!(!args.is_empty(), "wrong argument count");
+
+    let doc_dir = match cx.editor.current_buffer_directory() {
+        Some(p) => p,
+        None => bail!("current buffer has no path or parent"),
+    };
+    let doc_dir = doc_dir.to_string_lossy();
+
+    // Transform all arguments, performance may be poor, but doesn't matter:
+    let args = args
+        .iter()
+        .map(|a| Cow::from(format!("{doc_dir}/{a}")))
+        .collect::<Vec<_>>();
+
+    open(cx, &args[..], event)
+}
+
 fn buffer_close_by_ids_impl(
     cx: &mut compositor::Context,
     doc_ids: &[DocumentId],
@@ -331,12 +357,14 @@ fn write_impl(
     cx: &mut compositor::Context,
     path: Option<&Cow<str>>,
     force: bool,
+    format: bool,
 ) -> anyhow::Result<()> {
     let config = cx.editor.config();
     let jobs = &mut cx.jobs;
     let (view, doc) = current!(cx.editor);
     let path = path.map(AsRef::as_ref);
 
+    // TODO: don't insert the newline if the user deleted it...
     if config.insert_final_newline {
         insert_final_newline(doc, view.id);
     }
@@ -344,8 +372,16 @@ fn write_impl(
     // Save an undo checkpoint for any outstanding changes.
     doc.append_changes_to_history(view);
 
-    let fmt = if config.auto_format {
-        doc.auto_format().map(|fmt| {
+    let fmt = if format {
+        doc.format()
+    } else if config.auto_format {
+        doc.auto_format()
+    } else {
+        None
+    };
+
+    if let Some(fmt) = fmt {
+        if true {
             let callback = make_format_callback(
                 doc.id(),
                 doc.version(),
@@ -355,12 +391,8 @@ fn write_impl(
             );
 
             jobs.add(Job::with_callback(callback).wait_before_exiting());
-        })
+        }
     } else {
-        None
-    };
-
-    if fmt.is_none() {
         let id = doc.id();
         cx.editor.save(id, path, force)?;
     }
@@ -386,7 +418,7 @@ fn write(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), false)
+    write_impl(cx, args.first(), false, false)
 }
 
 fn force_write(
@@ -398,7 +430,7 @@ fn force_write(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), true)
+    write_impl(cx, args.first(), true, false)
 }
 
 fn write_buffer_close(
@@ -410,7 +442,7 @@ fn write_buffer_close(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), false)?;
+    write_impl(cx, args.first(), false, false)?;
 
     let document_ids = buffer_gather_paths_impl(cx.editor, args);
     buffer_close_by_ids_impl(cx, &document_ids, false)
@@ -425,7 +457,7 @@ fn force_write_buffer_close(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), true)?;
+    write_impl(cx, args.first(), true, false)?;
 
     let document_ids = buffer_gather_paths_impl(cx.editor, args);
     buffer_close_by_ids_impl(cx, &document_ids, false)
@@ -464,6 +496,30 @@ fn format(
     Ok(())
 }
 
+fn format_write(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    write_impl(cx, args.first(), false, true)
+}
+
+fn format_write_force(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    write_impl(cx, args.first(), true, true)
+}
+
 fn set_indent_style(
     cx: &mut compositor::Context,
     args: &[Cow<str>],
@@ -626,7 +682,7 @@ fn write_quit(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), false)?;
+    write_impl(cx, args.first(), false, false)?;
     cx.block_try_flush_writes()?;
     quit(cx, &[], event)
 }
@@ -640,7 +696,7 @@ fn force_write_quit(
         return Ok(());
     }
 
-    write_impl(cx, args.first(), true)?;
+    write_impl(cx, args.first(), true, false)?;
     cx.block_try_flush_writes()?;
     force_quit(cx, &[], event)
 }
@@ -1731,6 +1787,43 @@ fn hsplit_new(
     Ok(())
 }
 
+fn focus(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    ensure!(!args.is_empty(), "Window number is required");
+    let num: usize = args.first().unwrap().parse()?;
+    let view = cx.editor.tree.views_sorted_by_position().nth(num - 1);
+
+    if let Some(view) = view {
+        cx.editor.focus(view.id)
+    } else {
+        cx.editor
+            .set_error(format!("Window {} doesn't exist!", num))
+    }
+
+    Ok(())
+}
+
+fn focus_insert(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    // Focus firstly:
+    focus(cx, args, event)?;
+
+    // Then enter the insert mode:
+    cx.editor.mode = Mode::Insert;
+
+    Ok(())
+}
+
 fn debug_eval(
     cx: &mut compositor::Context,
     args: &[Cow<str>],
@@ -2561,6 +2654,13 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
         fun: open,
         signature: CommandSignature::all(completers::filename),
     },
+    TypableCommand {
+        name: "open-in-current",
+        aliases: &["O", "E"],
+        doc: "Open a file based on current buffer's directory.",
+        fun: open_in_current,
+        signature: CommandSignature::all(completers::filename_in_current),
+    },
     TypableCommand {
         name: "buffer-close",
         aliases: &["bc", "bclose"],
@@ -2659,6 +2759,20 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
         fun: format,
         signature: CommandSignature::none(),
     },
+    TypableCommand {
+        name: "format-write",
+        aliases: &["m"],
+        doc: "Format the document, then write.",
+        fun: format_write,
+        signature: CommandSignature::none(),
+    },
+    TypableCommand {
+        name: "format-write!",
+        aliases: &["m!"],
+        doc: "Format the document, then write forcibily.",
+        fun: format_write_force,
+        signature: CommandSignature::none(),
+    },
     TypableCommand {
         name: "indent-style",
         aliases: &[],
@@ -2984,6 +3098,20 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
         fun: hsplit_new,
         signature: CommandSignature::none(),
     },
+    TypableCommand {
+        name: "focus",
+        aliases: &[],
+        doc: "Focus a window by number.",
+        fun: focus,
+        signature: CommandSignature::none(),
+    },
+    TypableCommand {
+        name: "focus_insert",
+        aliases: &[],
+        doc: "Focus a window by number, then enter insert mode.",
+        fun: focus_insert,
+        signature: CommandSignature::none(),
+    },
     TypableCommand {
         name: "tutor",
         aliases: &[],
diff --git a/helix-term/src/keymap.rs b/helix-term/src/keymap.rs
index 020ecaf4..2e1743d4 100644
--- a/helix-term/src/keymap.rs
+++ b/helix-term/src/keymap.rs
@@ -72,18 +72,31 @@ pub fn merge(&mut self, mut other: Self) {
         }
     }
 
-    pub fn infobox(&self) -> Info {
-        let mut body: Vec<(BTreeSet<KeyEvent>, &str)> = Vec::with_capacity(self.len());
+    pub fn infobox(&self, editor: &helix_view::Editor) -> Info {
+        let mut body: Vec<(BTreeSet<KeyEvent>, String)> = Vec::with_capacity(self.len());
         for (&key, trie) in self.iter() {
             let desc = match trie {
                 KeyTrie::MappableCommand(cmd) => {
                     if cmd.name() == "no_op" {
                         continue;
                     }
-                    cmd.doc()
+
+                    // Special handling for ":toggle_option", we show the current value as well.
+                    // TODO: more generic approach, to make other mappable/typable commands work.
+                    match cmd {
+                        MappableCommand::Typable { name, args, .. } if name == "toggle-option" => {
+                            let pointer = format!("/{}", args[0].replace('.', "/"));
+                            let value = serde_json::json!(editor.config().deref())
+                                .pointer(&pointer)
+                                .unwrap()
+                                .clone();
+                            format!("{} ?{}", cmd.doc(), value)
+                        }
+                        _ => cmd.doc().to_string(),
+                    }
                 }
-                KeyTrie::Node(n) => &n.name,
-                KeyTrie::Sequence(_) => "[Multiple commands]",
+                KeyTrie::Node(n) => n.name.to_string(),
+                KeyTrie::Sequence(_) => "[Multiple commands]".to_string(),
             };
             match body.iter().position(|(_, d)| d == &desc) {
                 Some(pos) => {
diff --git a/helix-term/src/keymap/default.rs b/helix-term/src/keymap/default.rs
index c6cefd92..1ebb8529 100644
--- a/helix-term/src/keymap/default.rs
+++ b/helix-term/src/keymap/default.rs
@@ -17,7 +17,8 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "F" => find_prev_char,
         "r" => replace,
         "R" => replace_with_yanked,
-        "A-." =>  repeat_last_motion,
+        // "." => repeat_last_insert is defined in @see command_mode
+        "A-." => repeat_last_motion,
 
         "~" => switch_case,
         "`" => switch_to_lowercase,
@@ -77,7 +78,6 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "C" => copy_selection_on_next_line,
         "A-C" => copy_selection_on_prev_line,
 
-
         "s" => select_regex,
         "A-s" => split_selection_on_newline,
         "A-minus" => merge_selections,
@@ -113,6 +113,7 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
             "g" => goto_prev_change,
             "G" => goto_first_change,
             "f" => goto_prev_function,
+            "n" => goto_prev_function_name,
             "t" => goto_prev_class,
             "a" => goto_prev_parameter,
             "c" => goto_prev_comment,
@@ -127,6 +128,7 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
             "g" => goto_next_change,
             "G" => goto_last_change,
             "f" => goto_next_function,
+            "n" => goto_next_function_name,
             "t" => goto_next_class,
             "a" => goto_next_parameter,
             "c" => goto_next_comment,
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 5d028415..814d1070 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -887,7 +887,7 @@ fn handle_keymap_event(
         let mut last_mode = mode;
         self.pseudo_pending.extend(self.keymaps.pending());
         let key_result = self.keymaps.get(mode, event);
-        cxt.editor.autoinfo = self.keymaps.sticky().map(|node| node.infobox());
+        cxt.editor.autoinfo = self.keymaps.sticky().map(|node| node.infobox(&cxt.editor));
 
         let mut execute_command = |command: &commands::MappableCommand| {
             command.execute(cxt);
@@ -918,7 +918,7 @@ fn handle_keymap_event(
             KeymapResult::Matched(command) => {
                 execute_command(command);
             }
-            KeymapResult::Pending(node) => cxt.editor.autoinfo = Some(node.infobox()),
+            KeymapResult::Pending(node) => cxt.editor.autoinfo = Some(node.infobox(&cxt.editor)),
             KeymapResult::MatchedSequence(commands) => {
                 for command in commands {
                     execute_command(command);
@@ -1582,10 +1582,11 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
                 cx.editor.theme.get("ui.text")
             };
 
-            surface.set_string(
+            surface.set_stringn(
                 area.x,
                 area.y + area.height.saturating_sub(1),
                 status_msg,
+                area.width as usize,
                 style,
             );
         }
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index 6ee49fa5..337d969a 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -19,7 +19,9 @@
 use crate::job::{self, Callback};
 pub use completion::Completion;
 pub use editor::EditorView;
+use helix_core::regex;
 use helix_stdx::rope;
+use helix_view::editor::SearchConfig;
 pub use markdown::Markdown;
 pub use menu::Menu;
 pub use picker::{Column as PickerColumn, FileLocation, Picker};
@@ -69,6 +71,32 @@ pub fn prompt_with_input(
     cx.push_layer(Box::new(prompt));
 }
 
+pub fn transform_search_query(config: &SearchConfig, query: &str) -> (String, bool) {
+    let case_insensitive = if config.case_sensitive {
+        false
+    } else if config.smart_case {
+        !query.chars().any(char::is_uppercase)
+    } else {
+        false
+    };
+
+    let input = if !config.regex {
+        regex::escape(query)
+    } else {
+        // TODO: avoid copy
+        query.to_string()
+    };
+
+    return (
+        if config.whole_word {
+            format!(r"\b{}\b", input)
+        } else {
+            input
+        },
+        case_insensitive,
+    );
+}
+
 pub fn regex_prompt(
     cx: &mut crate::commands::Context,
     prompt: std::borrow::Cow<'static, str>,
@@ -84,6 +112,7 @@ pub fn regex_prompt(
         move |cx, regex, _, event| fun(cx, regex, event),
     );
 }
+
 pub fn raw_regex_prompt(
     cx: &mut crate::commands::Context,
     prompt: std::borrow::Cow<'static, str>,
@@ -114,19 +143,14 @@ pub fn raw_regex_prompt(
                         return;
                     }
 
-                    let case_insensitive = if config.search.smart_case {
-                        !input.chars().any(char::is_uppercase)
-                    } else {
-                        false
-                    };
-
+                    let (input, case_insensitive) = transform_search_query(&config.search, input);
                     match rope::RegexBuilder::new()
                         .syntax(
                             rope::Config::new()
                                 .case_insensitive(case_insensitive)
                                 .multi_line(true),
                         )
-                        .build(input)
+                        .build(input.as_str())
                     {
                         Ok(regex) => {
                             let (view, doc) = current!(cx.editor);
@@ -139,7 +163,7 @@ pub fn raw_regex_prompt(
                                 view.jumps.push((doc_id, snapshot.clone()));
                             }
 
-                            fun(cx, regex, input, event);
+                            fun(cx, regex, input.as_str(), event);
 
                             let (view, doc) = current!(cx.editor);
                             view.ensure_cursor_in_view(doc, config.scrolloff);
@@ -357,6 +381,27 @@ pub fn filename(editor: &Editor, input: &str) -> Vec<Completion> {
         filename_with_git_ignore(editor, input, true)
     }
 
+    pub fn filename_in_current(editor: &Editor, input: &str) -> Vec<Completion> {
+        // @see open_in_current
+        let doc_path = match editor.current_buffer_directory() {
+            Some(p) => p,
+            None => return Vec::new(),
+        };
+
+        let doc_path = doc_path.to_string_lossy();
+        let input = format!("{doc_path}/{input}");
+
+        // Should complete at the "really" input end (the user typed):
+        // @see change_completion_selection
+        filename_with_git_ignore(editor, input.as_str(), true)
+            .iter()
+            .map(|p| {
+                let start = p.0.start - doc_path.len() - 1;
+                (start.., p.1.clone())
+            })
+            .collect()
+    }
+
     pub fn filename_with_git_ignore(
         editor: &Editor,
         input: &str,
diff --git a/helix-term/src/ui/picker.rs b/helix-term/src/ui/picker.rs
index df8d52eb..6879de47 100644
--- a/helix-term/src/ui/picker.rs
+++ b/helix-term/src/ui/picker.rs
@@ -98,7 +98,7 @@ pub enum Preview<'picker, 'editor> {
 }
 
 impl Preview<'_, '_> {
-    fn document(&self) -> Option<&Document> {
+    pub fn document(&self) -> Option<&Document> {
         match self {
             Preview::EditorDocument(doc) => Some(doc),
             Preview::Cached(CachedPreview::Document(doc)) => Some(doc),
@@ -175,11 +175,10 @@ pub fn push(&self, item: T) -> Result<(), InjectorShutdown> {
     }
 }
 
-type ColumnFormatFn<T, D> = for<'a> fn(&'a T, &'a D) -> Cell<'a>;
-
 pub struct Column<T, D> {
     name: Arc<str>,
-    format: ColumnFormatFn<T, D>,
+    /// Accept a closure, trading some performance against customization:
+    format: Arc<dyn for<'a> Fn(&'a T, &'a D) -> Cell<'a> + Send + Sync>,
     /// Whether the column should be passed to nucleo for matching and filtering.
     /// `DynamicPicker` uses this so that the dynamic column (for example regex in
     /// global search) is not used for filtering twice.
@@ -188,10 +187,14 @@ pub struct Column<T, D> {
 }
 
 impl<T, D> Column<T, D> {
-    pub fn new(name: impl Into<Arc<str>>, format: ColumnFormatFn<T, D>) -> Self {
+    pub fn new<F>(name: impl Into<Arc<str>>, format: F) -> Self
+    where
+        F: for<'a> Fn(&'a T, &'a D) -> Cell<'a> + Send + Sync,
+        F: 'static,
+    {
         Self {
             name: name.into(),
-            format,
+            format: Arc::new(format),
             filter: true,
             hidden: false,
         }
@@ -199,11 +202,9 @@ pub fn new(name: impl Into<Arc<str>>, format: ColumnFormatFn<T, D>) -> Self {
 
     /// A column which does not display any contents
     pub fn hidden(name: impl Into<Arc<str>>) -> Self {
-        let format = |_: &T, _: &D| unreachable!();
-
         Self {
             name: name.into(),
-            format,
+            format: Arc::new(|_: &T, _: &D| unreachable!()),
             filter: false,
             hidden: true,
         }
@@ -224,6 +225,74 @@ fn format_text<'a>(&self, item: &'a T, data: &'a D) -> Cow<'a, str> {
     }
 }
 
+const CACHE_READ_AHEAD_SIZE: usize = 1024;
+
+pub struct DocumentPreviewCache {
+    /// Caches paths to documents
+    preview_cache: HashMap<Arc<Path>, CachedPreview>,
+    read_buffer: Vec<u8>,
+}
+
+impl DocumentPreviewCache {
+    pub fn new() -> Self {
+        Self {
+            preview_cache: HashMap::new(),
+            read_buffer: Vec::with_capacity(CACHE_READ_AHEAD_SIZE),
+        }
+    }
+
+    /// Get (cached) preview for the currently selected item. If a document corresponding
+    /// to the path is already open in the editor, it is used instead.
+    pub fn get_preview<'picker, 'editor>(
+        &'picker mut self,
+        path: &Path,
+        editor: &'editor Editor,
+    ) -> Preview<'picker, 'editor> {
+        if let Some(doc) = editor.document_by_path(path) {
+            return Preview::EditorDocument(doc);
+        }
+
+        // TODO: Performance?
+        let path: Arc<Path> = path.into();
+        if self.preview_cache.contains_key(&path) {
+            let preview = &self.preview_cache[&path];
+            return Preview::Cached(preview);
+        }
+
+        let data = std::fs::File::open(&path).and_then(|file| {
+            let metadata = file.metadata()?;
+            // Read up to 1kb to detect the content type
+            let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
+            let content_type = content_inspector::inspect(&self.read_buffer[..n]);
+            self.read_buffer.clear();
+            Ok((metadata, content_type))
+        });
+
+        let preview = data
+            .map(
+                |(metadata, content_type)| match (metadata.len(), content_type) {
+                    (_, content_inspector::ContentType::BINARY) => CachedPreview::Binary,
+                    (size, _) if size > MAX_FILE_SIZE_FOR_PREVIEW => CachedPreview::LargeFile,
+                    _ => Document::open(&path, None, None, editor.config.clone())
+                        .map(|doc| CachedPreview::Document(Box::new(doc)))
+                        .unwrap_or(CachedPreview::NotFound),
+                },
+            )
+            .unwrap_or(CachedPreview::NotFound);
+
+        self.preview_cache.insert(path.clone(), preview);
+        Preview::Cached(&self.preview_cache[&path])
+    }
+
+    pub fn get_mut(&mut self, path: &Arc<Path>) -> Option<&mut CachedPreview> {
+        self.preview_cache.get_mut(path)
+    }
+
+    pub fn next(&self) -> Option<&CachedPreview> {
+        self.preview_cache.values().next()
+    }
+}
+
 /// Returns a new list of options to replace the contents of the picker
 /// when called with the current picker query,
 type DynQueryCallback<T, D> =
@@ -251,9 +320,7 @@ pub struct Picker<T: 'static + Send + Sync, D: 'static> {
     callback_fn: PickerCallback<T>,
 
     pub truncate_start: bool,
-    /// Caches paths to documents
-    preview_cache: HashMap<Arc<Path>, CachedPreview>,
-    read_buffer: Vec<u8>,
+    preview_cache: DocumentPreviewCache,
     /// Given an item in the picker, return the file path and line number to display.
     file_fn: Option<FileCallback<T>>,
     /// An event handler for syntax highlighting the currently previewed file.
@@ -356,7 +423,7 @@ fn with(
 
         let widths = columns
             .iter()
-            .map(|column| Constraint::Length(column.name.chars().count() as u16))
+            .map(|column| Constraint::Length(column.name.chars().count() as u16 + 1u16))
             .collect();
 
         let query = PickerQuery::new(columns.iter().map(|col| &col.name).cloned(), default_column);
@@ -375,8 +442,7 @@ fn with(
             callback_fn: Box::new(callback_fn),
             completion_height: 0,
             widths,
-            preview_cache: HashMap::new(),
-            read_buffer: Vec::with_capacity(1024),
+            preview_cache: DocumentPreviewCache::new(),
             file_fn: None,
             preview_highlight_handler: PreviewHighlightHandler::<T, D>::default().spawn(),
             dynamic_query_handler: None,
@@ -410,8 +476,28 @@ pub fn with_preview(
         self
     }
 
-    pub fn with_history_register(mut self, history_register: Option<char>) -> Self {
+    pub fn with_cached_previews(mut self, preview_cache: DocumentPreviewCache) -> Self {
+        self.preview_cache = preview_cache;
+        self
+    }
+
+    pub fn with_history_register(
+        mut self,
+        history_register: Option<char>,
+        editor: &Editor,
+    ) -> Self {
         self.prompt.with_history_register(history_register);
+
+        // If the prompt has a history completion and is empty, accept it now
+        if let Some(completion) = self
+            .prompt
+            .first_history_completion(editor)
+            .filter(|_| self.prompt.line().is_empty())
+        {
+            self.prompt.set_line(completion.to_string(), editor);
+            self.handle_prompt_change(true);
+        }
+
         self
     }
 
@@ -565,61 +651,29 @@ fn get_preview<'picker, 'editor>(
         let current = self.selection()?;
         let (path_or_id, range) = (self.file_fn.as_ref()?)(editor, current)?;
 
-        match path_or_id {
+        let preview = match path_or_id {
             PathOrId::Path(path) => {
-                if let Some(doc) = editor.document_by_path(path) {
-                    return Some((Preview::EditorDocument(doc), range));
-                }
-
-                if self.preview_cache.contains_key(path) {
-                    // NOTE: we use `HashMap::get_key_value` here instead of indexing so we can
-                    // retrieve the `Arc<Path>` key. The `path` in scope here is a `&Path` and
-                    // we can cheaply clone the key for the preview highlight handler.
-                    let (path, preview) = self.preview_cache.get_key_value(path).unwrap();
-                    if matches!(preview, CachedPreview::Document(doc) if doc.language_config().is_none())
-                    {
-                        helix_event::send_blocking(&self.preview_highlight_handler, path.clone());
-                    }
-                    return Some((Preview::Cached(preview), range));
-                }
-
-                let path: Arc<Path> = path.into();
-                let data = std::fs::File::open(&path).and_then(|file| {
-                    let metadata = file.metadata()?;
-                    // Read up to 1kb to detect the content type
-                    let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
-                    let content_type = content_inspector::inspect(&self.read_buffer[..n]);
-                    self.read_buffer.clear();
-                    Ok((metadata, content_type))
-                });
-                let preview = data
-                    .map(
-                        |(metadata, content_type)| match (metadata.len(), content_type) {
-                            (_, content_inspector::ContentType::BINARY) => CachedPreview::Binary,
-                            (size, _) if size > MAX_FILE_SIZE_FOR_PREVIEW => {
-                                CachedPreview::LargeFile
-                            }
-                            _ => Document::open(&path, None, None, editor.config.clone())
-                                .map(|doc| {
-                                    // Asynchronously highlight the new document
-                                    helix_event::send_blocking(
-                                        &self.preview_highlight_handler,
-                                        path.clone(),
-                                    );
-                                    CachedPreview::Document(Box::new(doc))
-                                })
-                                .unwrap_or(CachedPreview::NotFound),
-                        },
-                    )
-                    .unwrap_or(CachedPreview::NotFound);
-                self.preview_cache.insert(path.clone(), preview);
-                Some((Preview::Cached(&self.preview_cache[&path]), range))
+                // TODO: avoid deeply copied 'to_owned'?
+                let path = path.to_owned();
+                self.preview_cache.get_preview(path.as_path(), editor)
             }
             PathOrId::Id(id) => {
                 let doc = editor.documents.get(&id).unwrap();
-                Some((Preview::EditorDocument(doc), range))
+                Preview::EditorDocument(doc)
+            }
+        };
+
+        if let Preview::Cached(CachedPreview::Document(doc)) = preview {
+            // TODO: Simplify?
+            if doc.language_config().is_none() {
+                helix_event::send_blocking(
+                    &self.preview_highlight_handler,
+                    doc.path().unwrap().clone().into(),
+                );
             }
         }
+
+        Some((preview, range))
     }
 
     fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
@@ -780,8 +834,8 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
             .column_spacing(1)
             .widths(&self.widths);
 
-        // -- Header
-        if self.columns.len() > 1 {
+        // -- Header, always show; with `if true` to keep indent for git diff
+        if true {
             let active_column = self.query.active_column(self.prompt.position());
             let header_style = cx.editor.theme.get("ui.picker.header");
             let header_column_style = cx.editor.theme.get("ui.picker.header.column");
@@ -798,7 +852,9 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
                                 header_column_style
                             };
 
-                        Cell::from(Span::styled(Cow::from(&*column.name), style))
+                        // Add a prefix % to indicate you can filter with it
+                        let name = format!("%{}", &*column.name);
+                        Cell::from(Span::styled(Cow::from(name), style))
                     }
                 }))
                 .style(header_style),
@@ -1018,17 +1074,7 @@ fn handle_event(&mut self, event: &Event, ctx: &mut Context) -> EventResult {
                 }
             }
             key!(Enter) => {
-                // If the prompt has a history completion and is empty, use enter to accept
-                // that completion
-                if let Some(completion) = self
-                    .prompt
-                    .first_history_completion(ctx.editor)
-                    .filter(|_| self.prompt.line().is_empty())
-                {
-                    self.prompt.set_line(completion.to_string(), ctx.editor);
-                    // Inserting from the history register is a paste.
-                    self.handle_prompt_change(true);
-                } else {
+                if true {
                     if let Some(option) = self.selection() {
                         (self.callback_fn)(ctx, option, Action::Replace);
                     }
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index f44020c5..53ac6f50 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -320,6 +320,13 @@ pub fn kill_to_end_of_line(&mut self, editor: &Editor) {
         self.recalculate_completion(editor);
     }
 
+    fn kill_whole_line(&mut self, editor: &Editor) {
+        self.line = String::new();
+        self.cursor = 0;
+
+        self.recalculate_completion(editor);
+    }
+
     pub fn clear(&mut self, editor: &Editor) {
         self.line.clear();
         self.cursor = 0;
@@ -566,6 +573,10 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
                 self.kill_to_start_of_line(cx.editor);
                 (self.callback_fn)(cx, &self.line, PromptEvent::Update);
             }
+            alt!('k') => {
+                self.kill_whole_line(cx.editor);
+                (self.callback_fn)(cx, &self.line, PromptEvent::Update);
+            }
             ctrl!('h') | key!(Backspace) | shift!(Backspace) => {
                 self.delete_char_backwards(cx.editor);
                 (self.callback_fn)(cx, &self.line, PromptEvent::Update);
diff --git a/helix-term/src/ui/statusline.rs b/helix-term/src/ui/statusline.rs
index 7437cbd0..8630a578 100644
--- a/helix-term/src/ui/statusline.rs
+++ b/helix-term/src/ui/statusline.rs
@@ -139,6 +139,7 @@ fn get_render_function<F>(element_id: StatusLineElementID) -> impl Fn(&mut Rende
 {
     match element_id {
         helix_view::editor::StatusLineElement::Mode => render_mode,
+        helix_view::editor::StatusLineElement::Window => render_window_number,
         helix_view::editor::StatusLineElement::Spinner => render_lsp_spinner,
         helix_view::editor::StatusLineElement::FileBaseName => render_file_base_name,
         helix_view::editor::StatusLineElement::FileName => render_file_name,
@@ -163,6 +164,7 @@ fn get_render_function<F>(element_id: StatusLineElementID) -> impl Fn(&mut Rende
         helix_view::editor::StatusLineElement::Spacer => render_spacer,
         helix_view::editor::StatusLineElement::VersionControl => render_version_control,
         helix_view::editor::StatusLineElement::Register => render_register,
+        helix_view::editor::StatusLineElement::SearchConfig => render_search_config,
     }
 }
 
@@ -200,6 +202,27 @@ fn render_mode<F>(context: &mut RenderContext, write: F)
     );
 }
 
+fn render_window_number<F>(context: &mut RenderContext, write: F)
+where
+    F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
+{
+    context.view.id;
+    let id = 1 + context
+        .editor
+        .tree
+        .views_sorted_by_position()
+        .enumerate()
+        .find(|(_, v)| v.id == context.view.id)
+        .unwrap()
+        .0;
+    // little bit *colorful*
+    write(
+        context,
+        format!(" {{{} ", id),
+        Some(context.editor.theme.get("magenta")),
+    );
+}
+
 // TODO think about handling multiple language servers
 fn render_lsp_spinner<F>(context: &mut RenderContext, write: F)
 where
@@ -531,3 +554,22 @@ fn render_register<F>(context: &mut RenderContext, write: F)
         write(context, format!(" reg={} ", reg), None)
     }
 }
+
+fn render_search_config<F>(context: &mut RenderContext, write: F)
+where
+    F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
+{
+    // TODO: place to ui/editor.rs using `status_msg`?
+    let sc = &context.editor.config().search;
+    write(
+        context,
+        format!(
+            " ({}{}{}{}) ",
+            if sc.regex { 'r' } else { ' ' },
+            if sc.case_sensitive { 'c' } else { ' ' },
+            if sc.smart_case { 's' } else { ' ' },
+            if sc.whole_word { 'w' } else { ' ' }
+        ),
+        None,
+    )
+}
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 14628988..942c2153 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -1768,6 +1768,26 @@ pub fn remove_language_server_by_name(&mut self, name: &str) -> Option<Arc<Clien
         self.language_servers.remove(name)
     }
 
+    // TODO: Merge with language_servers_with_feature:
+    pub fn arc_language_servers_with_feature(
+        &self,
+        feature: LanguageServerFeature,
+    ) -> impl Iterator<Item = Arc<helix_lsp::Client>> + '_ {
+        self.language_config().into_iter().flat_map(move |config| {
+            config.language_servers.iter().filter_map(move |features| {
+                let ls = self.language_servers.get(&features.name)?.clone();
+                if ls.is_initialized()
+                    && ls.supports_feature(feature)
+                    && features.has_feature(feature)
+                {
+                    Some(ls)
+                } else {
+                    None
+                }
+            })
+        })
+    }
+
     pub fn language_servers_with_feature(
         &self,
         feature: LanguageServerFeature,
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index 151b2653..2ccef199 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -474,6 +474,12 @@ pub struct SearchConfig {
     pub smart_case: bool,
     /// Whether the search should wrap after depleting the matches. Default to true.
     pub wrap_around: bool,
+    /// Forced case sensitive. Defaults to false, the smart_case is respected when false.
+    pub case_sensitive: bool,
+    /// Search whole word. Defaults to false.
+    pub whole_word: bool,
+    /// Use regex all the places. Defaults to true.
+    pub regex: bool,
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
@@ -493,6 +499,7 @@ fn default() -> Self {
         Self {
             left: vec![
                 E::Mode,
+                E::Window,
                 E::Spinner,
                 E::FileName,
                 E::ReadOnlyIndicator,
@@ -503,6 +510,7 @@ fn default() -> Self {
                 E::Diagnostics,
                 E::Selections,
                 E::Register,
+                E::SearchConfig,
                 E::Position,
                 E::FileEncoding,
             ],
@@ -536,6 +544,9 @@ pub enum StatusLineElement {
     /// The editor mode (Normal, Insert, Visual/Selection)
     Mode,
 
+    /// Window Number
+    Window,
+
     /// The LSP activity spinner
     Spinner,
 
@@ -595,6 +606,9 @@ pub enum StatusLineElement {
 
     /// Indicator for selected register
     Register,
+
+    /// Indicator for the search config (sensetive or else), TODO: global
+    SearchConfig,
 }
 
 // Cursor shape is read and used on every rendered frame and so needs
@@ -1010,6 +1024,9 @@ fn default() -> Self {
         Self {
             wrap_around: true,
             smart_case: true,
+            case_sensitive: false,
+            whole_word: false,
+            regex: true,
         }
     }
 }
@@ -1429,6 +1446,13 @@ pub fn move_path(&mut self, old_path: &Path, new_path: &Path) -> io::Result<()>
         Ok(())
     }
 
+    // TODO: current_buffer().directory()
+    pub fn current_buffer_directory(&self) -> Option<PathBuf> {
+        doc!(self)
+            .path()
+            .and_then(|path| path.parent().map(|path| path.to_path_buf()))
+    }
+
     pub fn set_doc_path(&mut self, doc_id: DocumentId, path: &Path) {
         let doc = doc_mut!(self, &doc_id);
         let old_path = doc.path();
diff --git a/helix-view/src/tree.rs b/helix-view/src/tree.rs
index aba947a2..54382384 100644
--- a/helix-view/src/tree.rs
+++ b/helix-view/src/tree.rs
@@ -1,5 +1,6 @@
 use crate::{graphics::Rect, View, ViewId};
 use slotmap::HopSlotMap;
+use std::{collections::BinaryHeap, convert::identity, iter};
 
 // the dimensions are recomputed on window resize/tree change.
 //
@@ -280,6 +281,12 @@ pub fn views(&self) -> impl Iterator<Item = (&View, bool)> {
         })
     }
 
+    pub fn views_sorted_by_position(&self) -> impl Iterator<Item = &View> {
+        // TODO: the `into_iter_sorted` of BinaryHeap is unstable...
+        let mut heap = self.views().map(|(v, _)| v).collect::<BinaryHeap<_>>();
+        iter::repeat_with(move || heap.pop()).map_while(identity)
+    }
+
     pub fn views_mut(&mut self) -> impl Iterator<Item = (&mut View, bool)> {
         let focus = self.focus;
         self.nodes
diff --git a/helix-view/src/view.rs b/helix-view/src/view.rs
index a229f01e..a61100a1 100644
--- a/helix-view/src/view.rs
+++ b/helix-view/src/view.rs
@@ -19,6 +19,7 @@
 };
 
 use std::{
+    cmp::Ordering,
     collections::{HashMap, VecDeque},
     fmt,
 };
@@ -167,6 +168,32 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     }
 }
 
+impl Eq for View {}
+
+// TODO: This sorts the view by x/y axis...
+impl PartialEq for View {
+    fn eq(&self, other: &Self) -> bool {
+        self.area.x == other.area.x && self.area.y == other.area.y
+    }
+}
+
+// The binary heap is reversed...
+impl Ord for View {
+    fn cmp(&self, other: &Self) -> Ordering {
+        other
+            .area
+            .x
+            .cmp(&self.area.x)
+            .then_with(|| other.area.y.cmp(&self.area.y))
+    }
+}
+
+impl PartialOrd for View {
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
 impl View {
     pub fn new(doc: DocumentId, gutters: GutterConfig) -> Self {
         Self {
diff --git a/runtime/queries/c/textobjects.scm b/runtime/queries/c/textobjects.scm
index 63ec4a56..26fd35d9 100644
--- a/runtime/queries/c/textobjects.scm
+++ b/runtime/queries/c/textobjects.scm
@@ -1,3 +1,6 @@
+(function_declarator
+  declarator: (identifier) @function_name.inside)
+
 (function_definition
   body: (_) @function.inside) @function.around
 
diff --git a/runtime/queries/python/textobjects.scm b/runtime/queries/python/textobjects.scm
index 2b9556fc..85cb1241 100644
--- a/runtime/queries/python/textobjects.scm
+++ b/runtime/queries/python/textobjects.scm
@@ -1,4 +1,5 @@
 (function_definition
+  name: (identifier) @function_name.inside
   body: (block)? @function.inside) @function.around
 
 (class_definition
diff --git a/runtime/queries/rust/textobjects.scm b/runtime/queries/rust/textobjects.scm
index de517d36..d3b77e23 100644
--- a/runtime/queries/rust/textobjects.scm
+++ b/runtime/queries/rust/textobjects.scm
@@ -1,4 +1,5 @@
 (function_item
+  name: (_) @function_name.inside
   body: (_) @function.inside) @function.around
 
 (closure_expression
